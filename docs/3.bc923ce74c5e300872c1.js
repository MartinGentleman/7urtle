(window.webpackJsonp=window.webpackJsonp||[]).push([[3],{496:function(e,t,n){"use strict";n.r(t);var a=n(60),o=n.n(a),i=n(1),l=n.n(i),r=n(5),s=n(27),u=n(29),c=n(44),m=n(103),p=n(39),d=n(6),g=n(11),h=[{name:"Improve your programming skills"},{name:"KISS functional programming"},{name:"Inversion of control and dependency injection"},{name:"Write shorter code"},{name:"Easily improve code performance"},{name:"Enjoy programming more"}],f=function(e){return"lambda-"+Object(d.o)(Object(d.s)("-")(/ /g)(e))};t.default=function(){var e=Object(i.useState)(!1),t=o()(e,2),n=t[0],a=t[1];return Object(i.useEffect)((function(){return window.addEventListener("scroll",(function(){return window.pageYOffset>0?a(!0):a(!1)}))}),[]),l.a.createElement(s.a,null,l.a.createElement("header",{className:"whiteBackground"},l.a.createElement(r.i,null,l.a.createElement("h1",null,l.a.createElement("div",null,l.a.createElement("strong",null,"@7urtle"),"/lambda"),"JavaScript functional programming advantages"))),l.a.createElement("article",{className:"whiteBackground textLeft pb6 plr1"},l.a.createElement(r.i,null,l.a.createElement(r.t,null,l.a.createElement(r.g,{md:"3",className:"LearnSideMenu d-none d-md-block"},l.a.createElement("h2",{className:"pt-0"},"JavaScript functional programming advantages"),l.a.createElement(p.a,{contents:h,sorted:!1})),l.a.createElement(r.g,null,l.a.createElement("p",null,l.a.createElement("strong",null,"Functional programming")," is not a new thing. It is a ",l.a.createElement("strong",null,"declarative programming paradigm"),"based on ",l.a.createElement("strong",null,"lambda calculus")," from 1930s. In 1937, ",l.a.createElement("strong",null,"Alan Turing"),"  himself proved that lambda calculus and Turing machines are equivalent computational systems. You don't need to learn any of the underlying mathematics but the math is there to make your coding easier. First functional programming language, ",l.a.createElement("strong",null,"LISP"),", was developed in 1950s. 70 years later, functional programming principles made their way into all major imperative object-oriented languages including ",l.a.createElement("strong",null,"Java"),", ",l.a.createElement("strong",null,"C#"),", or ",l.a.createElement("strong",null,"Python"),"."),l.a.createElement("p",null,l.a.createElement("strong",null,"JavaScript")," through its support of ",l.a.createElement("a",{href:g.b.LambdaBasics.url+"#lambda-first-class-functions",title:g.b.LambdaBasics.description},"first-class functions")," is ideal for you to take ",l.a.createElement("strong",null,"advantage of functional programming"),"."),l.a.createElement("p",null,"Learning ",l.a.createElement("strong",null,"functional programming")," improves all your programming skills. It teaches you about general best practices for programming like inversion of control or the single responsibility principle. It also helps you write shorter, more reusable, and performant code. Not to mention that for many developers writing in a functional style is just more fun."),l.a.createElement("h2",{className:"pt-2",id:f(h[0].name)},h[0].name),l.a.createElement("p",null,"It is important to know programming best practice to develop robust solution that will survive into the future. Following best practices has always required continuous study of programming as well discipline to apply in your code. Functional programming is different in a sense that it is designed to lead you towards those practices without you having to always be conscious and disciplined about it."),l.a.createElement("h3",{id:f(h[1].name)},h[1].name),l.a.createElement("p",null,l.a.createElement("strong",null,"KISS")," means ",l.a.createElement("strong",null,"Keep It Simple Stupid")," and it is a principle that says that ",l.a.createElement("em",null,"simple code design should be always preferred"),". It relates to the single responsibility principle that says: ",l.a.createElement("em",null,"Every function should have responsibility over a single part of the functionality.")," That means that one function should do one thing."),l.a.createElement("p",null,"If you goal was to write a function that always trims its input and turns it into upper case shouting, you would likely write it like this in imperative code:"),l.a.createElement(c.a,{language:"javascript",code:"const shout = function (input) {\n  input = input.trim().toUpperCase();\n  const lastLetter = input.substr(-1);\n  \n  if ('.?!,'.includes(lastLetter)) {\n    input = input.substr(0, input.length -1) + '!';\n  } else {\n    input = input + '!';\n  }\n\n  return input;\n};\n\nshout(\" Don't forget to feed the turtle.\"); // => DON'T FORGET TO FEED THE TURTLE!"}),l.a.createElement("p",null,"It is natural to focus on the overall task which is to build a function that does what we want and build a full function that delivers on the task. It takes discipline then to realize how to break the function down into its single responsibility parts."),l.a.createElement("p",null,"This is also a reason why defensive programming is asking you to write a test for every step of your code. Large functions and classes have a tendency to hide a lot of internal logic if your unit test focuses only on a simple test of their output."),l.a.createElement("p",null,"Now let's write the same function using ",l.a.createElement("strong",null,"@7urtle/lambda")," and ",l.a.createElement("a",{href:g.b.LambdaBasics.url,title:g.b.LambdaBasics.description},"functional programming principles of function composition"),"."),l.a.createElement(c.a,{language:"javascript",code:"import {trim, upperCaseOf, lengthOf, lastLetterOf, includes, compose} from '@7urtle/lambda';\n\nconst endsWithPunctuation = input => includes(lastLetterOf(input))('.?,!');\nconst replacePunctuationWithExclamation = input => substr(lengthOf(input) - 1)(0)(input) + '!';\nconst addExclamationMark = input => endsWithPunctuation(input) ? replacePunctuationWithExclamation(input) : input + '!';\n\nconst shout = compose(addExclamationMark, upperCaseOf, trim);\n\nshout(\" Don't forget to feed the turtle.\"); // => DON'T FORGET TO FEED THE TURTLE!`"}),l.a.createElement("p",null,"The functional code follows the principle of single responsibility and we end up with four easily testable and highly reusable functions ",l.a.createElement("code",null,"endsWithPunctuation"),", ",l.a.createElement("code",null,"replacePunctuationWithExclamation"),", ",l.a.createElement("code",null,"addExclamationMark"),", and ",l.a.createElement("code",null,"shout"),". When you look at the function ",l.a.createElement("code",null,"shout"),", it is easy to deduce that the function return trimmed upper-case of its input with an exclamation mark. In the original code you have to read to whole function to understand what it does."),l.a.createElement("h3",{id:f(h[2].name)},h[2].name),l.a.createElement("p",null,"Commonly your function calls a function from a framework to realize its purpose.",l.a.createElement("strong",null,"Inversion of control")," means that a framework is calling your function to execute custom purpose.",l.a.createElement("strong",null,"Dependency injection")," is a type of inversion of control. Dependency is an external code that your function is dependent on, and injection is the act of providing it to your function."))))),l.a.createElement(u.a,null),n&&l.a.createElement(m.a,{scrolled:n,setScrolled:a}))}}}]);