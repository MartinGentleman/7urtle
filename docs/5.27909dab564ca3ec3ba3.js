(window.webpackJsonp=window.webpackJsonp||[]).push([[5],{497:function(e,a,t){"use strict";t.r(a);var n=t(54),r=t.n(n),o=t(1),l=t.n(o),s=t(4),i=t(27),c=t(29),u=t(34),m=t(103),f=t(42),d=t(11),p=t(40),h=t(24),g=[{name:"map"},{name:"flatMap"},{name:"ap"},{name:"Maybe there is a value"},{name:"Either it is Success or Failure"},{name:"It depends on the Case"},{name:"Trigger dangerous SyncEffect lazily"},{name:"Master lazy asynchronous AsyncEffect"}],y=function(e){return"lambda-"+Object(h.c)(e)};a.default=function(){var e=Object(o.useState)(!1),a=r()(e,2),t=a[0],n=a[1];return Object(o.useEffect)((function(){return window.addEventListener("scroll",(function(){return window.pageYOffset>0?n(!0):n(!1)}))}),[]),l.a.createElement(i.a,null,l.a.createElement("header",{className:"whiteBackground"},l.a.createElement(s.i,null,l.a.createElement("h1",null,l.a.createElement("div",null,l.a.createElement("strong",null,"@7urtle"),"/lambda"),"Managing side effects with monads in JavaScript"))),l.a.createElement("article",{className:"whiteBackground textLeft pb6 plr1"},l.a.createElement(s.i,null,l.a.createElement(s.t,null,l.a.createElement(s.g,{md:"3",className:"LearnSideMenu d-none d-md-block"},l.a.createElement("p",null,l.a.createElement(p.a,{target:d.b.Learn},"â€¹ Learn")),l.a.createElement("h2",{className:"pt-0"},"Managing side effects with monads in JavaScript"),l.a.createElement(f.a,{contents:g,sorted:!1})),l.a.createElement(s.g,null,l.a.createElement("p",null,"Instead of explaining the laws governing ",l.a.createElement("strong",null,"monads")," and explaining that ",l.a.createElement("em",null,"monad is just a monoid in the category of endofunctors"),", we will focus on the practical application of monads with ",l.a.createElement("strong",null,"@7urtle/lambda"),"."),l.a.createElement("p",null,"To simplify things you can understand monads as wrappers that aim to simplify the dealing with ",l.a.createElement("strong",null,"side effects, errors, inputs, outputs, and asynchronous code"),"."),l.a.createElement("p",null,"As you probably know, ",l.a.createElement("strong",null,"functional programming")," is very particular about ",l.a.createElement(p.a,{target:d.b.LambdaBasics},"keeping your functions pure")," dependent only on their inputs and not causing any external effects. But real life usually requires your code to read data from somewhere and then save or display some results. Among side effects, you can count output into console, reading files, updating database, editing DOM, saving data, and so on. For all of these you can use monads."),l.a.createElement("p",null,"In ",l.a.createElement("strong",null,"@7urtle/lambda")," we have ",l.a.createElement("code",null,"Maybe"),", ",l.a.createElement("code",null,"Either"),", ",l.a.createElement("code",null,"Case"),",",l.a.createElement("code",null,"SyncEffect"),", and ",l.a.createElement("code",null,"AsyncEffect"),". All of these are ",l.a.createElement("strong",null,"functors"),", ",l.a.createElement("strong",null,"monads"),", and ",l.a.createElement("strong",null,"applicatives")," at the same time because they implement methods ",l.a.createElement("strong",null,"map, flatMap, and ap"),"."),l.a.createElement("h3",{className:"pt-2",id:y(g[0].name)},g[0].name),l.a.createElement("p",null,"Every ",l.a.createElement("strong",null,"functor")," has the method ",l.a.createElement("code",null,"map"),". ",l.a.createElement("code",null,"map")," allows you to apply a function on a value that the functor wraps around safely. It's all easier to understand on an example:"),l.a.createElement(u.a,{language:"javascript",code:"import {deepInspect, map} from '@7urtle/lambda';\n\n// we define our own functor Functor\nconst Functor = {\n  of: value => ({\n    value: value,\n    inspect: () => `Functor(${deepInspect(value)})`,\n    map: fn => Functor.of(fn(value))\n  })\n};\n\nconst add1 = a => a + 1;\n\n// we wrap Functor around the value 1\nconst myFunctor = Functor.of(1); // Functor(1)\nmyFunctor.inspect(); // => 'Functor(1)'\n\n// we map the function add1 on the value inside the functor\nconst myFunctorPlus1 = myFunctor.map(add1); // Functor(2)\n\nmyFunctorPlus1.value; // => 2\nmyFunctor.map(a => a + 1).value; // => 2\nmyFunctor.value; // => 1, no mutation\n\n// you can also apply function map on a functor with the same result\nmyFunctorPlus1again = map(add1)(myFunctor);\nmyFunctorPlus1again.value === myFunctorPlus1.value; // => true\n\n// it is the same map that we use for arrays\nmap(add1)([1, 2]); // => [2, 3]"}),l.a.createElement("p",null,"Now if you understand the example and how the function ",l.a.createElement("code",null,"map")," works, ",l.a.createElement("strong",null,"you now understand the basics of functors in functional programming"),". Specialized monads then add a special magic to these and you can learn about that later when those are discussed."),l.a.createElement("h3",{className:"pt-2",id:y(g[1].name)},g[1].name),l.a.createElement("p",null,"If you had a function that returns a functor and you mapped the function on a functor, you would end up with a functor inside of a functor. Every ",l.a.createElement("strong",null,"monad")," has the method ",l.a.createElement("code",null,"flatMap"),". ",l.a.createElement("code",null,"flatMap")," allows you to map a function the same as ",l.a.createElement("code",null,"map")," but it expects that the mapped function returns the same type of monad as is the type of the monad that we are mapping it on. It deals with it by flattening the result into a simple value inside of a monad instead of a value in a monad in a monad. Here is an example:"),l.a.createElement(u.a,{language:"javascript",code:"import {deepInspect, flatMap} from '@7urtle/lambda';\n\n// we define our own monad Monad\nconst Monad = {\n  of: value => ({\n    value: value,\n    inspect: () => `Monad(${deepInspect(value)})`,\n    map: fn => Monad.of(fn(value)),\n    flatMap: fn => fn(value)\n  })\n};\n\n// we wrap Monad around the value 1\nconst myMonad = Monad.of(1); // Monad(1)\n\nconst add1Monad = a => Monad.of(a + 1);\n\n// we map the function add1 on the value inside the monad\nmyMonad.map(add1Monad); // Monad(Monad(2));\nconst myMonadPlus1 = myMonad.flatMap(add1Monad); // Monad(2)\n\nmyMonadPlus1.value; // => 2\nmyMonad.value; // => 1, no mutation\n\n// you can also apply function flatMap on a monad with the same result\nmyMonadPlus1again = map(add1Monad)(myMonad);\nmyMonadPlus1again === myMonadPlus1; // => true"}),l.a.createElement("p",null,"Now if you understand the example and how the function ",l.a.createElement("code",null,"flatMap")," works, ",l.a.createElement("strong",null,"you now understand the basics of monads in functional programming"),"."),l.a.createElement("h3",{className:"pt-2",id:y(g[2].name)},g[2].name),l.a.createElement("p",null,"Because in ",l.a.createElement("strong",null,"functional programming")," we also love ",l.a.createElement(p.a,{target:d.b.LambdaBasics},"partial application"),", we have ",l.a.createElement("strong",null,"applicatives")," and their method ",l.a.createElement("code",null,"ap"),". ",l.a.createElement("code",null,"ap")," allows you to map curried functions that require multiple values using ",l.a.createElement("code",null,"map")," and apply those values using ",l.a.createElement("code",null,"ap"),". More in the following example:"),l.a.createElement(u.a,{language:"javascript",code:"import {deepInspect} from '@7urtle/lambda';\n\n// we define our own applicative Applicative\nconst Applicative = {\n  of: value => ({\n    value: value,\n    inspect: () => `Applicative(${deepInspect(value)})`,\n    map: fn => Applicative.of(fn(value)),\n    flatMap: fn => fn(value),\n    ap: f => f.map(value)\n  })\n};\n\n// we wrap Applicative around the value 1\nconst myApplicative = Applicative.of(1); // Applicative(1)\n\nconst add = a => b => a + b;\n\n// we map the function add on the applicative\nconst myApplicativePartial = myApplicative.map(add); // Applicative(1 + b);\nconst myApplicativePlus1 = myApplicativePartial.ap(Applicative.of(1)); // Applicative(2)\nconst myApplicativePlus3 = myApplicativePartial.ap(Applicative.of(3)); // Applicative(4)\n\nmyApplicativePlus1.value; // => 2\nmyApplicative.value; // => 1, no mutation\n\n// you can also apply function flatMap on a monad with the same result\nmyMonadPlus1again = map(add1Monad)(myMonad);\nmyMonadPlus1again === myMonadPlus1; // => true"}),l.a.createElement("p",null,"Now if you understand the example and how the function ",l.a.createElement("code",null,"ap")," works, ",l.a.createElement("strong",null,"you now understand the basics of applicatives in functional programming"),"."),l.a.createElement("p",null,l.a.createElement("strong",null,"@7urtle/lambda")," also gives you functions ",l.a.createElement("strong",null,"liftA2")," and ",l.a.createElement("strong",null,"liftA3")," to simplify writing functions that work with applicatives. It takes a regular function that expects simple values and turns it into a function that supports applicatives:"),l.a.createElement(u.a,{language:"javascript",code:"import {liftA2} from '@7urtle/lambda';\n\nconst add = a => b => a + b;\n\nconst addAp = liftA2(add);\n\nmyResultApplicative = addAp(Applicative.of(2))(Applicative.of(3));\nmyResultApplicative.value; // => 5"}),l.a.createElement("p",null,"Now all that remains is the magic of specific monads in ",l.a.createElement("strong",null,"@7urtle/lambda"),"."),l.a.createElement("h2",{className:"pt-2",id:y(g[3].name)},g[3].name),l.a.createElement("p",null,l.a.createElement("strong",null,"Maybe")," is the most simple monad to learn. Maybe expects to maybe get a value as its input. It evaluates whether the value is ",l.a.createElement("strong",null,"Nothing")," (empty, null, or undefined) or ",l.a.createElement("strong",null,"Just"),"."),l.a.createElement(u.a,{language:"javascript",code:"import {Maybe, maybe, isNothing, sJust} from '@7urtle/lambda';\n\nMaybe.of('some value'); // Just('some value');\nMaybe.of(''); // Nothing\nMaybe.of([]); // Nothing\nMaybe.of({}); // Nothing\nMaybe.of(null); // Nothing\nMaybe.of(undefined); // Nothing\n\nMaybe.of(5).isJust(); // => true\nMaybe.of(5).value; // => 5\nMaybe.of([]).isNothing(); // => true\nMaybe.of([]).value; // => []\n\n// function maybe is there to help you process the result\nconst testMaybe =\n  maybe\n  ('Maybe is Nothing')\n  (value => 'Maybe is: ' + value);\n  \ntestMaybe(Maybe.of([])); // => 'Maybe is Nothing'\ntestMaybe(Maybe.of('something')); // => 'Maybe is: something'\n\n// @7urtle/lambda also provides independent isNothing and isJust functions\nisNothing(''); // => true\nisJust(''); // => false"}),l.a.createElement("p",null,l.a.createElement("strong",null,"Maybe")," allows you to safely map over its value as ",l.a.createElement("strong",null,"the mapped function is applied only if the value is Just"),"."),l.a.createElement(u.a,{language:"javascript",code:"import {Maybe} from '@7urtle/lambda';\n\nMaybe.of(5).map(a => a + 5); // Just(10)\nMaybe.of(undefined).map(a => a + 5); // Nothing\n\nMaybe.of(5).flatMap(a => Maybe.of(a + 5)); // Just(10)\nMaybe.of(undefined).flatMap(a => Maybe.of(a + 5)); // Nothing\n\nMaybe.of(5).map(a => b => a + b).ap(Maybe.of(5)); // Just(10)\nMaybe.of(undefined).map(a => b => a + b).ap(Maybe.of(5)); // Nothing"}),l.a.createElement("p",null,"Your own function should return ",l.a.createElement("strong",null,"Maybe")," in cases that you are unsure that there is an output usually in when you are working with side effects. For example you can use it like this when ",l.a.createElement("strong",null,"working with DOM"),":"),l.a.createElement(u.a,{language:"javascript",code:"import {Maybe, map, compose} from '@7urtle/lambda';\n\n// returns DOM element or undefined if the element #imayexist doesn't exist\ndocument.querySelector('#imayxist');\n\n// returns position from top or throws and error if the element doesn't exist\ndocument.querySelector('#imayxist').offsetTop;\n\n// Let's try it with Maybe without any worry about throwing errors\nconst selectMaybeDOM = selector =>  Maybe.of(document.querySelector(selector));\nconst getPositionFromTop = element => element.offsetTop;\nconst getMaybePositionFromTopDOM = compose(map(getPositionFromTop), selectMaybeDOM);\n\n// or just one line (which goes against single responsibility principle)\nconst getMaybePositionFromTopDOM2 = selector => Maybe.of(document.querySelector(selector)).map(a => a.offsetTop));\n\nconst MaybeResult = getMaybePositionFromTopDOM('#imayexist');\nMaybeResult.isNothing() ? 'Element does not exist' : 'I have result ' + MaybeResult.value;"}),l.a.createElement("h2",{className:"pt-2",id:y(g[4].name)},g[4].name),l.a.createElement("p",null,l.a.createElement("strong",null,"Either")," is another simple monad to learn. Either represents either ",l.a.createElement("strong",null,"Success")," or ",l.a.createElement("strong",null,"Failure")," of execution to allow you to manage error states in your code. For your convenience there is also a function ",l.a.createElement("code",null,"try")," to help with ",l.a.createElement("strong",null,"try/catch"),"for functions in nodejs that may throw an error."),l.a.createElement(u.a,{language:"javascript",code:"import {Either, either} from '@7urtle/lambda';\n\nEither.of('ok'); // Success('ok')\nEither.of('ok').value; // => 'ok'\n\nEither.Success('ok'); // Success('ok')\nEither.Failure('error'); // Failure('error')\n\nconst iThrowError = () => {\n  throw new Error('I am an error.');\n};\n\nEither.try(() => 'ok'); // Success('ok')\nEither.try(iThrowError); // Failure('I am an error.')\n\n// function either is there to help you process the result\nconst testEither =\n  either\n  (error => 'There is an error: ' + error)\n  (value => 'Your result is: ' + value);\n  \ntestEither(Either.Success('ok')); // => 'Your result is: ok'\ntestEither(Either.Failure('error')); // => 'There is an error: error'"}),l.a.createElement("p",null,l.a.createElement("strong",null,"Either")," allows you to safely map over its value as ",l.a.createElement("strong",null,"the mapped function is applied only if the value is Success"),"."),l.a.createElement(u.a,{language:"javascript",code:"import {Either} from '@7urtle/lambda';\n\nEither.of(5).map(a => a + 5); // Success(10)\nEither.Failure(5).map(a => a + 5); // Failure(5)\n\nEither.of(5).flatMap(a => Either.of(a + 5)); // Success(10)\nEither.Failure('error').flatMap(a => Either.of(a + 5)); // Failure('error')\n\nEither.of(5).map(a => b => a + b).ap(Either.of(5)); // Success(10)\nEither.Failure('error').map(a => b => a + b).ap(Either.of(5)); // Failure('error')"}),l.a.createElement("p",null,"Your own function should return ",l.a.createElement("strong",null,"Either")," to express that there is some error usually in a connection with working with side effects. Consider this example of working with ",l.a.createElement("strong",null,"nodejs reading a file"),":"),l.a.createElement(u.a,{language:"javascript",code:"import {Either, either} from '@7urtle/lambda';\nimport fs from 'fs';\n\nconst readFileEither = file => Either.try(fs.readFileSync(file));\n\nconst data = readFileEither('i/may/not/exist.txt');\n\ndata.isFailure() ? 'there is an error ' + data.value : 'your data ' + data.value;"}),l.a.createElement("p",null,"Or consider an example of working with ",l.a.createElement("strong",null,"DOM where querySelector throws an error")," if its selector has the wrong format:"),l.a.createElement(u.a,{language:"javascript",code:"import {Either, isNothing, flatMap, compose} from '@7urtle/lambda';\n\ndocument.querySelector('@'); // Uncaught DOMException: Failed to execute 'querySelector' on 'Document': '@' is not a valid selector.\n\nconst querySelectorEither = selector => Either.try(() => document.querySelector(selector));\nconst getClientHeightEither = flatMap(value => isNothing(value) ? Either.Failure('Element does not exist.') : Either.Success(value.clientHeight));\nconst selectHeightEither = compose(getClientHeightEither, querySelectorEither);\n\nselectHeightEither('@'); // Failure('Uncaught DOMException: Failed to execute 'querySelector' on 'Document': '@' is not a valid selector.')\nselectHeightEither('#idontexist'); // Failure('Element does not exist.')\nselectHeightEither('#iexist'); // Success(333);\n\nconst testEither =\n  either\n  (error => 'There is an error: ' + error)\n  (value => 'Your result is: ' + value);\n  \ntestEither(selectHeightEither('#iexist')); // => 'Your result is: 333'"}),l.a.createElement("h2",{className:"pt-2",id:y(g[5].name)},g[5].name),l.a.createElement("p",null,l.a.createElement("strong",null,"Case")," is a monad representing a simple map with a matching mechanism. You can use use it as a replacement for a switch with monad enhancements."),l.a.createElement(u.a,{language:"javascript",code:"import {Case} from '@7urtle/lambda';\n\n// Case expect key-value pairs as its input\nconst myCase = Case.of([\n  [1, 'one'],\n  ['key', 'value'],\n  ['_', 'fallback'] // '_' represents default fallback option\n]);\n\n// you reach a value by matching keys using Case.match\nmyCase.match(1); // => 'one'\nmyCase.match('key'); // => 'value'\nmyCase.match('nope'); // => 'fallback'\n\n// if no fallback is defined and no key is matched, we return undefined\nCase.of([]).match('nope'); // => undefined"}),l.a.createElement("p",null,l.a.createElement("strong",null,"Case")," allows you to safely map over its value as ",l.a.createElement("strong",null,"the mapped function is applied only after ",l.a.createElement("code",null,"match")," is called"),"."),l.a.createElement(u.a,{language:"javascript",code:"import {Case, upperCaseOf, liftA2} from '@7urtle/lambda';\n\nCase.of([['key', 'value']]).map(upperCaseOf).match('key'); // => 'VALUE'\n\n// you can merge Cases together by using flatMap\nCase.of([[1, 'I am']]).flatMap(a => Case.of([[1, a + ' a turtle']]).match(1); // => 'I am a turtle'\n\n// case is also an applicative so you can use partial application\nconst add = a => b => a + b;\nliftA2(add)(Case.of([[1, 1]]))(Case.of([[1, 2]])).match(1); // => 3"}),l.a.createElement("h2",{className:"pt-2",id:y(g[6].name)},g[6].name),l.a.createElement("p",null,l.a.createElement("strong",null,"SyncEffect")," is a wrapper for dangerous functions adding lazy evaluation through its trigger. That means that the wrapped around ",l.a.createElement("strong",null,"function is not executed until a trigger is called"),". SyncEffect serves as a monad to signal that there is some potential dangerous side effect that is not handled. The use of the monad is quite simple:"),l.a.createElement(u.a,{language:"javascript",code:"import {SyncEffect} from '@7urtle/lambda';\n\n// we create SyncEffect that expects a number from 0 to 1\n// and based on that, it returns a value or throws an error\nconst throwError = () => {throw 'random failure'};\nconst dangerousFunction = value => value > 0.5 ? 'random success' : throwError();\nconst mySyncEffect = SyncEffect.of(dangerousFunction);\n\n// when you are ready, you can call trigger to trigger the side effect\n// nothing is executed until the trigger is called\n// if you pass value to a trigger it is used a an argument for the wrapped around function\nmySyncEffect.trigger(Math.random());\n// => returns 'random success' or throws 'random failure' depending on Math.random() value"}),l.a.createElement("p",null,l.a.createElement("strong",null,"SyncEffect")," allows you to safely map over its value as ",l.a.createElement("strong",null,"the mapped function is applied only after ",l.a.createElement("code",null,"trigger")," is called"),"."),l.a.createElement(u.a,{language:"javascript",code:"import {SyncEffect, upperCaseOf, liftA2} from '@7urtle/lambda';\n\nconst throwError = () => {throw 'random failure'};\nconst dangerousFunction = value => value > 0.5 ? 'random success' : throwError();\nconst mySyncEffect = SyncEffect.of(dangerousFunction);\n\n// as a functor the value inside is safely mappable\n// map doesn't execute in case of an error and nothing executes until a trigger is called\nmySyncEffect\n.map(value => upperCaseOf(value))\n.trigger(Math.random());\n// => returns 'RANDOM SUCCESS' or throws 'random failure' depending on Math.random() value\n\n// as a monad SyncEffect can be safely flat mapped with other SyncEffects\n// flatMap doesn't execute in case of an error and nothing executes until a trigger is called\nSyncEffect.of(() => '7turtle').flatMap(a => SyncEffect.of(() => a + 's')).trigger();\n\n// as an applicative functor you can apply SyncEffects to each other especially using liftA2 or liftA3\nconst add = a => b => a + b;\nliftA2(add)(SyncEffect.of(() => 1)(SyncEffect.of(() => 2)).trigger(); // => 3\nSyncEffect.of(() => add).ap(SyncEffect.of(() => 1)).ap(SyncEffect.of(() => 2)).trigger(); // => 3"}),l.a.createElement("p",null,"You can use ",l.a.createElement("strong",null,"SyncEffect")," in a similar situations as the monad ",l.a.createElement("strong",null,"Either"),". The difference is that you are deferring handling the potential negative effects."),l.a.createElement(u.a,{language:"javascript",code:"import {SyncEffect, liftA2, Either} from '@7urtle/lambda';\n\nconst getElementHeightSyncEffect = selector => SyncEffect.of(document.querySelector(selector).clientHeight);\ngetElementHeightSyncEffect('#iexist'); // => 333\ngetElementHeightSyncEffect('#idontexist'); // Uncaught TypeError: Cannot read property 'clientHeight' of null\n\nconst addAp = LiftA2(a => b => a + b);\n\naddAp(getElementHeightSyncEffect('@'))(getElementHeightSyncEffect('#iexist')).trigger();\n// 'Uncaught DOMException: Failed to execute 'querySelector' on 'Document': '@' is not a valid selector.'\n\nyou can still use the monad Either to handle the potential error state\nconst getElementHeightEither = selector => Either.try(getElementHeightSyncEffect(selector).trigger);\ngetElementHeightEither('@').isFailure(); // => true"}),l.a.createElement("h2",{className:"pt-2",id:y(g[7].name)},g[7].name),l.a.createElement("p",null,l.a.createElement("strong",null,"AsyncEffect")," is a wrapper for dangerous asynchronous functions adding lazy evaluation through its trigger. That means that the wrapped around ",l.a.createElement("strong",null,"function is not executed until a trigger is called"),". AsyncEffect is similar to Promise because its trigger also expects reject and resolve functions that are called based on AsyncEffect execution. Reject function is also called if there is an error thrown."),l.a.createElement(u.a,{language:"javascript",code:"import {AsyncEffect, log} from '@7urtle/lambda';\n\n// we create AsyncEffect that expects a number from 0 to 1\n// and based on that, it resolve or rejects 10 milliseconds after it is triggered\nconst myAsyncEffect = AsyncEffect\n  .of(reject => resolve => value =>\n    setTimeout(() => value > 0.5 ? resolve('random success') : reject('random failure'), 10)\n);\n\n// when you are ready, you can call trigger to trigger the side effect\n// nothing is executed until the trigger is called\nmyAsyncEffect\n.trigger\n(error => log(error))\n(result => log(result))\n(Math.random());\n// => logs 'random success' or 'random failure' depending on Math.random() value\n\n// you can also turn AsyncEffect into a JavaScript Promise\nmyAsyncEffect\n.promise(Math.random())\n.then(result => log(result), error => log(error));\n// => logs 'random success' or 'random failure' depending on Math.random() value\n\n// thrown exceptions lead AsyncEffect to reject\nAsyncEffect\n.of(() => {\n    throw 'error';\n})\n.trigger(log)(log)();\n// => logs 'error'"}),l.a.createElement("p",null,l.a.createElement("strong",null,"AsyncEffect")," allows you to safely map over its value as ",l.a.createElement("strong",null,"the mapped function is applied only after ",l.a.createElement("code",null,"trigger")," is called"),"."),l.a.createElement(u.a,{language:"javascript",code:"import {AsyncEffect, upperCaseOf, liftA2} from '@7urtle/lambda';\n\nconst myAsyncEffect = AsyncEffect\n  .of(reject => resolve => value =>\n    setTimeout(() => value > 0.5 ? resolve('random success') : reject('random failure'), 10)\n);\n\n// as a functor the value inside is safely mappable\n// map doesn't execute in case of an error and nothing executes until a trigger is called\nmyAsyncEffect\n.map(value => upperCaseOf(value))\n.trigger(log)(log)(Math.random());\n// => logs 'RANDOM SUCCESS' or 'random failure' depending on Math.random() value\n\n// as a monad AsyncEffect can be safely flat mapped with other AsyncEffects\n// flatMap doesn't execute in case of an error and nothing executes until a trigger is called\nAsyncEffect\n.of(reject => resolve => value => resolve(value))\n.flatMap(a => AsyncEffect.of(reject => resolve => value => resolve(a + 's')))\n.trigger(log)(log)('7urtle');\n// => logs '7urtles'\n\n// as an applicative functor you can apply AsyncEffects to each other especially using liftA2 or liftA3\nconst add = a => b => a + b;\nconst AS1 = AsyncEffect.of(reject => resolve => value => resolve(1));\nconst AS2 = AsyncEffect.of(reject => resolve => value => resolve(2));\nliftA2(add)(AS1)(AS2); // => resolve(3)"}),l.a.createElement("p",null,"You can use ",l.a.createElement("strong",null,"AsyncEffect")," as an elegant wrapper around your ajax calls or work asynchronously with file reading/writing:"),l.a.createElement(u.a,{language:"javascript",code:"import {AsyncEffect} from '@7urtle/lambda';\nimport axios from 'axios';\nimport fs from 'fs';\n\n// axios example\nAsyncEffect\n.of(reject => resolve => value => axios.get(value).then(resolve, reject))\n.map(toUpperCaseOf)\n.trigger\n(error => log(error))\n(result => log(response.data))\n('/my/ajax/url');\n\n// reading file example\nexport const readFile => input =>\n  AsyncEffect\n  .of(reject => resolve => _ =>\n    fs.readFile(input, (err, data) =>\n      err ? reject(err) : resolve(data)\n    )\n  );"}))))),l.a.createElement(c.a,null),t&&l.a.createElement(m.a,{scrolled:t,setScrolled:n}))}}}]);