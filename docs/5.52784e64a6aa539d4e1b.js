(window.webpackJsonp=window.webpackJsonp||[]).push([[5],{497:function(e,a,t){"use strict";t.r(a);var n=t(54),l=t.n(n),o=t(1),r=t.n(o),i=t(4),s=t(27),u=t(29),c=t(34),m=t(103),p=t(42),d=t(11),h=t(40),f=t(24),y=[{name:"map"},{name:"flatMap"},{name:"ap"},{name:"Maybe there is a value"},{name:"Either it is Success or Failure"},{name:"It depends on the Case"},{name:"Trigger dangerous SyncEffect lazily"},{name:"Master lazy asynchronous AsyncEffect"}],E=function(e){return"lambda-"+Object(f.c)(e)};a.default=function(){var e=Object(o.useState)(!1),a=l()(e,2),t=a[0],n=a[1];return Object(o.useEffect)((function(){return window.addEventListener("scroll",(function(){return window.pageYOffset>0?n(!0):n(!1)}))}),[]),r.a.createElement(s.a,null,r.a.createElement("header",{className:"whiteBackground"},r.a.createElement(i.i,null,r.a.createElement("h1",null,r.a.createElement("div",null,r.a.createElement("strong",null,"@7urtle"),"/lambda"),"Managing side effects with monads in JavaScript"))),r.a.createElement("article",{className:"whiteBackground textLeft pb6 plr1"},r.a.createElement(i.i,null,r.a.createElement(i.t,null,r.a.createElement(i.g,{md:"3",className:"LearnSideMenu d-none d-md-block"},r.a.createElement("p",null,r.a.createElement(h.a,{target:d.b.Learn},"â€¹ Learn")),r.a.createElement("h2",{className:"pt-0"},"Managing side effects with monads in JavaScript"),r.a.createElement(p.a,{contents:y,sorted:!1})),r.a.createElement(i.g,null,r.a.createElement("p",null,"Instead of explaining the laws governing ",r.a.createElement("strong",null,"monads")," and explaining that ",r.a.createElement("em",null,"monad is just a monoid in the category of endofunctors"),", we will focus on the practical application of monads with ",r.a.createElement("strong",null,"@7urtle/lambda"),"."),r.a.createElement("p",null,"To simplify things you can understand monads as wrappers that aim to simplify the dealing with ",r.a.createElement("strong",null,"side effects, errors, inputs, outputs, and asynchronous code"),"."),r.a.createElement("p",null,"As you probably know, ",r.a.createElement("strong",null,"functional programming")," is very particular about ",r.a.createElement(h.a,{target:d.b.LambdaBasics},"keeping your functions pure")," dependent only on their inputs and not causing any external effects. But real life usually requires your code to read data from somewhere and then save or display some results. Among side effects, you can count output into console, reading files, updating database, editing DOM, saving data, and so on. For all of these you can use monads."),r.a.createElement("p",null,"In ",r.a.createElement("strong",null,"@7urtle/lambda")," we have ",r.a.createElement("code",null,"Maybe"),", ",r.a.createElement("code",null,"Either"),", ",r.a.createElement("code",null,"Case"),",",r.a.createElement("code",null,"SyncEffect"),", and ",r.a.createElement("code",null,"AsyncEffect"),". All of these are ",r.a.createElement("strong",null,"functors"),", ",r.a.createElement("strong",null,"monads"),", and ",r.a.createElement("strong",null,"applicatives")," at the same time because they implement methods ",r.a.createElement("strong",null,"map, flatMap, and ap"),"."),r.a.createElement("h3",{className:"pt-2",id:E(y[0].name)},y[0].name),r.a.createElement("p",null,"Every ",r.a.createElement("strong",null,"functor")," has the method ",r.a.createElement("code",null,"map"),". ",r.a.createElement("code",null,"map")," allows you to apply a function on a value that the functor wraps around safely. It's all easier to understand on an example:"),r.a.createElement(c.a,{language:"javascript",code:"import {deepInspect, map} from '@7urtle/lambda';\n\n// we define our own functor Functor\nconst Functor = {\n  of: value => ({\n    value: value,\n    inspect: () => `Functor(${deepInspect(value)})`,\n    map: fn => Functor.of(fn(value))\n  })\n};\n\nconst add1 = a => a + 1;\n\n// we wrap Functor around the value 1\nconst myFunctor = Functor.of(1); // Functor(1)\nmyFunctor.inspect(); // => 'Functor(1)'\n\n// we map the function add1 on the value inside the functor\nconst myFunctorPlus1 = myFunctor.map(add1); // Functor(2)\n\nmyFunctorPlus1.value; // => 2\nmyFunctor.map(a => a + 1).value; // => 2\nmyFunctor.value; // => 1, no mutation\n\n// you can also apply function map on a functor with the same result\nmyFunctorPlus1again = map(add1)(myFunctor);\nmyFunctorPlus1again.value === myFunctorPlus1.value; // => true\n\n// it is the same map that we use for arrays\nmap(add1)([1, 2]); // => [2, 3]"}),r.a.createElement("p",null,"Now if you understand the example and how the function ",r.a.createElement("code",null,"map")," works, ",r.a.createElement("strong",null,"you now understand the basics of functors in functional programming"),". Specialized monads then add a special magic to these and you can learn about that later when those are discussed."),r.a.createElement("h3",{className:"pt-2",id:E(y[1].name)},y[1].name),r.a.createElement("p",null,"If you had a function that returns a functor and you mapped the function on a functor, you would end up with a functor inside of a functor. Every ",r.a.createElement("strong",null,"monad")," has the method ",r.a.createElement("code",null,"flatMap"),". ",r.a.createElement("code",null,"flatMap")," allows you to map a function the same as ",r.a.createElement("code",null,"map")," but it expects that the mapped function returns the same type of monad as is the type of the monad that we are mapping it on. It deals with it by flattening the result into a simple value inside of a monad instead of a value in a monad in a monad. Here is an example:"),r.a.createElement(c.a,{language:"javascript",code:"import {deepInspect, flatMap} from '@7urtle/lambda';\n\n// we define our own monad Monad\nconst Monad = {\n  of: value => ({\n    value: value,\n    inspect: () => `Monad(${deepInspect(value)})`,\n    map: fn => Monad.of(fn(value)),\n    flatMap: fn => fn(value)\n  })\n};\n\n// we wrap Monad around the value 1\nconst myMonad = Monad.of(1); // Monad(1)\n\nconst add1Monad = a => Monad.of(a + 1);\n\n// we map the function add1 on the value inside the monad\nmyMonad.map(add1Monad); // Monad(Monad(2));\nconst myMonadPlus1 = myMonad.flatMap(add1Monad); // Monad(2)\n\nmyMonadPlus1.value; // => 2\nmyMonad.value; // => 1, no mutation\n\n// you can also apply function flatMap on a monad with the same result\nmyMonadPlus1again = map(add1Monad)(myMonad);\nmyMonadPlus1again === myMonadPlus1; // => true"}),r.a.createElement("p",null,"Now if you understand the example and how the function ",r.a.createElement("code",null,"flatMap")," works, ",r.a.createElement("strong",null,"you now understand the basics of monads in functional programming"),"."),r.a.createElement("h3",{className:"pt-2",id:E(y[2].name)},y[2].name),r.a.createElement("p",null,"Because in ",r.a.createElement("strong",null,"functional programming")," we also love ",r.a.createElement(h.a,{target:d.b.LambdaBasics},"partial application"),", we have ",r.a.createElement("strong",null,"applicatives")," and their method ",r.a.createElement("code",null,"ap"),". ",r.a.createElement("code",null,"ap")," allows you to map curried functions that require multiple values using ",r.a.createElement("code",null,"map")," and apply those values using ",r.a.createElement("code",null,"ap"),". More in the following example:"),r.a.createElement(c.a,{language:"javascript",code:"import {deepInspect} from '@7urtle/lambda';\n\n// we define our own applicative Applicative\nconst Applicative = {\n  of: value => ({\n    value: value,\n    inspect: () => `Applicative(${deepInspect(value)})`,\n    map: fn => Applicative.of(fn(value)),\n    flatMap: fn => fn(value),\n    ap: f => f.map(value)\n  })\n};\n\n// we wrap Applicative around the value 1\nconst myApplicative = Applicative.of(1); // Applicative(1)\n\nconst add = a => b => a + b;\n\n// we map the function add on the applicative\nconst myApplicativePartial = myApplicative.map(add); // Applicative(1 + b);\nconst myApplicativePlus1 = myApplicativePartial.ap(Applicative.of(1)); // Applicative(2)\nconst myApplicativePlus3 = myApplicativePartial.ap(Applicative.of(3)); // Applicative(4)\n\nmyApplicativePlus1.value; // => 2\nmyApplicative.value; // => 1, no mutation\n\n// you can also apply function flatMap on a monad with the same result\nmyMonadPlus1again = map(add1Monad)(myMonad);\nmyMonadPlus1again === myMonadPlus1; // => true"}),r.a.createElement("p",null,"Now if you understand the example and how the function ",r.a.createElement("code",null,"ap")," works, ",r.a.createElement("strong",null,"you now understand the basics of applicatives in functional programming"),"."),r.a.createElement("p",null,r.a.createElement("strong",null,"@7urtle/lambda")," also gives you functions ",r.a.createElement("strong",null,"liftA2")," and ",r.a.createElement("strong",null,"liftA3")," to simplify writing functions that work with applicatives. It takes a regular function that expects simple values and turns it into a function that supports applicatives:"),r.a.createElement(c.a,{language:"javascript",code:"import {liftA2} from '@7urtle/lambda';\n\nconst add = a => b => a + b;\n\nconst addAp = liftA2(add);\n\nmyResultApplicative = addAp(Applicative.of(2))(Applicative.of(3));\nmyResultApplicative.value; // => 5"}),r.a.createElement("p",null,"Now all that remains is the magic of specific monads in ",r.a.createElement("strong",null,"@7urtle/lambda"),"."),r.a.createElement("h2",{className:"pt-2",id:E(y[3].name)},y[3].name),r.a.createElement("p",null,r.a.createElement("strong",null,"Maybe")," is the most simple monad to learn. Maybe expects to maybe get a value as its input. It evaluates whether the value is ",r.a.createElement("strong",null,"Nothing")," (empty, null, or undefined) or ",r.a.createElement("strong",null,"Just"),"."),r.a.createElement(c.a,{language:"javascript",code:"import {Maybe, maybe, isNothing, sJust} from '@7urtle/lambda';\n\nMaybe.of('some value'); // Just('some value');\nMaybe.of(''); // Nothing\nMaybe.of([]); // Nothing\nMaybe.of({}); // Nothing\nMaybe.of(null); // Nothing\nMaybe.of(undefined); // Nothing\n\nMaybe.of(5).isJust(); // => true\nMaybe.of(5).value; // => 5\nMaybe.of([]).isNothing(); // => true\nMaybe.of([]).value; // => []\n\n// function maybe is there to help you process the result\nconst testMaybe =\n  maybe\n  ('Maybe is Nothing')\n  (value => 'Maybe is: ' + value);\n  \ntestMaybe(Maybe.of([])); // => 'Maybe is Nothing'\ntestMaybe(Maybe.of('something')); // => 'Maybe is: something'\n\n// @7urtle/lambda also provides independent isNothing and isJust functions\nisNothing(''); // => true\nisJust(''); // => false"}),r.a.createElement("p",null,r.a.createElement("strong",null,"Maybe")," allows you to safely map over its value as ",r.a.createElement("strong",null,"the mapped function is applied only if the value is Just"),"."),r.a.createElement(c.a,{language:"javascript",code:"import {Maybe} from '@7urtle/lambda';\n\nMaybe.of(5).map(a => a + 5); // Just(10)\nMaybe.of(undefined).map(a => a + 5); // Nothing\n\nMaybe.of(5).flatMap(a => Maybe.of(a + 5)); // Just(10)\nMaybe.of(undefined).flatMap(a => Maybe.of(a + 5)); // Nothing\n\nMaybe.of(5).map(a => b => a + b).ap(Maybe.of(5)); // Just(10)\nMaybe.of(undefined).map(a => b => a + b).ap(Maybe.of(5)); // Nothing"}),r.a.createElement("p",null,"Your own function should return ",r.a.createElement("strong",null,"Maybe")," in cases that you are unsure that there is an output usually in when you are working with side effects. For example you can use it like this when ",r.a.createElement("strong",null,"working with DOM"),":"),r.a.createElement(c.a,{language:"javascript",code:"import {Maybe, map, compose} from '@7urtle/lambda';\n\n// returns DOM element or undefined if the element #imayexist doesn't exist\ndocument.querySelector('#imayxist');\n\n// returns position from top or throws and error if the element doesn't exist\ndocument.querySelector('#imayxist').offsetTop;\n\n// Let's try it with Maybe without any worry about throwing errors\nconst selectMaybeDOM = selector =>  Maybe.of(document.querySelector(selector));\nconst getPositionFromTop = element => element.offsetTop;\nconst getMaybePositionFromTopDOM = compose(map(getPositionFromTop), selectMaybeDOM);\n\n// or just one line (which goes against single responsibility principle)\nconst getMaybePositionFromTopDOM2 = selector => Maybe.of(document.querySelector(selector)).map(a => a.offsetTop));\n\nconst MaybeResult = getMaybePositionFromTopDOM('#imayexist');\nMaybeResult.isNothing() ? 'Element does not exist' : 'I have result ' + MaybeResult.value;"}),r.a.createElement("h2",{className:"pt-2",id:E(y[4].name)},y[4].name),r.a.createElement("p",null,r.a.createElement("strong",null,"Either")," is another simple monad to learn. Either represents either ",r.a.createElement("strong",null,"Success")," or ",r.a.createElement("strong",null,"Failure")," of execution to allow you to manage error states in your code. For your convenience there is also a function ",r.a.createElement("code",null,"try")," to help with ",r.a.createElement("strong",null,"try/catch"),"for functions in nodejs that may throw an error."),r.a.createElement(c.a,{language:"javascript",code:"import {Either, either} from '@7urtle/lambda';\n\nEither.of('ok'); // Success('ok')\nEither.of('ok').value; // => 'ok'\n\nEither.Success('ok'); // Success('ok')\nEither.Failure('error'); // Failure('error')\n\nconst iThrowError = () => {\n  throw new Error('I am an error.');\n};\n\nEither.try(() => 'ok'); // Success('ok')\nEither.try(iThrowError); // Failure('I am an error.')\n\n// function either is there to help you process the result\nconst testEither =\n  either\n  (error => 'There is an error: ' + error)\n  (value => 'Your result is: ' + value);\n  \ntestEither(Either.Success('ok')); // => 'Your result is: ok'\ntestEither(Either.Failure('error')); // => 'There is an error: error'"}),r.a.createElement("p",null,r.a.createElement("strong",null,"Either")," allows you to safely map over its value as ",r.a.createElement("strong",null,"the mapped function is applied only if the value is Success"),"."),r.a.createElement(c.a,{language:"javascript",code:"import {Either} from '@7urtle/lambda';\n\nEither.of(5).map(a => a + 5); // Success(10)\nEither.Failure(5).map(a => a + 5); // Failure(5)\n\nEither.of(5).flatMap(a => Either.of(a + 5)); // Success(10)\nEither.Failure('error').flatMap(a => Either.of(a + 5)); // Failure('error')\n\nEither.of(5).map(a => b => a + b).ap(Either.of(5)); // Success(10)\nEither.Failure('error').map(a => b => a + b).ap(Either.of(5)); // Failure('error')"}),r.a.createElement("p",null,"Your own function should return ",r.a.createElement("strong",null,"Either")," to express that there is some error usually in a connection with working with side effects. Consider this example of working with ",r.a.createElement("strong",null,"nodejs reading a file"),":"),r.a.createElement(c.a,{language:"javascript",code:"import {Either, either} from '@7urtle/lambda';\nimport fs from 'fs';\n\nconst readFileEither = file => Either.try(fs.readFileSync(file));\n\nconst data = readFileEither('i/may/not/exist.txt');\n\ndata.isFailure() ? 'there is an error ' + data.value : 'your data ' + data.value;"}),r.a.createElement("p",null,"Or consider an example of working with ",r.a.createElement("strong",null,"DOM where querySelector throws an error")," if its selector has the wrong format:"),r.a.createElement(c.a,{language:"javascript",code:"import {Either, isNothing, flatMap, compose} from '@7urtle/lambda';\n\ndocument.querySelector('@'); // Uncaught DOMException: Failed to execute 'querySelector' on 'Document': '@' is not a valid selector.\n\nconst querySelectorEither = selector => Either.try(() => document.querySelector(selector));\nconst getClientHeightEither = flatMap(value => isNothing(value) ? Either.Failure('Element does not exist.') : Either.Success(value.clientHeight));\nconst selectHeightEither = compose(getClientHeightEither, querySelectorEither);\n\nselectHeightEither('@'); // Failure('Uncaught DOMException: Failed to execute 'querySelector' on 'Document': '@' is not a valid selector.')\nselectHeightEither('#idontexist'); // Failure('Element does not exist.')\nselectHeightEither('#iexist'); // Success(333);\n\nconst testEither =\n  either\n  (error => 'There is an error: ' + error)\n  (value => 'Your result is: ' + value);\n  \ntestEither(selectHeightEither('#iexist')); // => 'Your result is: 333'"}),r.a.createElement("h2",{className:"pt-2",id:E(y[5].name)},y[5].name),r.a.createElement("p",null,r.a.createElement("strong",null,"Case")," is a monad representing a simple map with a matching mechanism. You can use use it as a replacement for a switch with monad enhancements."),r.a.createElement(c.a,{language:"javascript",code:"import {Case} from '@7urtle/lambda';\n\n// Case expect key-value pairs as its input\nconst myCase = Case.of([\n  [1, 'one'],\n  ['key', 'value'],\n  ['_', 'fallback'] // '_' represents default fallback option\n]);\n\n// you reach a value by matching keys using Case.match\nmyCase.match(1); // => 'one'\nmyCase.match('key'); // => 'value'\nmyCase.match('nope'); // => 'fallback'\n\n// if no fallback is defined and no key is matched, we return undefined\nCase.of([]).match('nope'); // => undefined"}),r.a.createElement("p",null,r.a.createElement("strong",null,"Case")," allows you to safely map over its value as ",r.a.createElement("strong",null,"the mapped function is applied only after ",r.a.createElement("code",null,"match")," is Called"),"."),r.a.createElement(c.a,{language:"javascript",code:"import {Case, upperCaseOf, liftA2} from '@7urtle/lambda';\n\nCase.of([['key', 'value']]).map(upperCaseOf).match('key'); // => 'VALUE'\n\n// you can merge Cases together by using flatMap\nCase.of([[1, 'I am']]).flatMap(a => Case.of([[1, a + ' a turtle']]).match(1); // => 'I am a turtle'\n\n// case is also an applicative so you can use partial application\nconst add = a => b => a + b;\nliftA2(add)(Case.of([[1, 1]]))(Case.of([[1, 2]])).match(1); // => 3"}),r.a.createElement("h2",{className:"pt-2",id:E(y[6].name)},y[6].name),r.a.createElement("h2",{className:"pt-2",id:E(y[7].name)},y[7].name))))),r.a.createElement(u.a,null),t&&r.a.createElement(m.a,{scrolled:t,setScrolled:n}))}}}]);