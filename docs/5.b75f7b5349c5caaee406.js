(window.webpackJsonp=window.webpackJsonp||[]).push([[5],{497:function(e,a,n){"use strict";n.r(a);var t=n(54),l=n.n(t),o=n(1),c=n.n(o),u=n(4),r=n(27),i=n(29),m=n(34),s=n(103),d=n(42),p=n(11),f=n(40),h=n(24),v=[{name:"map"},{name:"flatMap"},{name:"ap"},{name:"Maybe there is a value"},{name:"Either it succeeds or fails"},{name:"It depends on the case"},{name:"Trigger dangerous execution lazily"},{name:"Handle asynchronous code"}],y=function(e){return"lambda-"+Object(h.c)(e)};a.default=function(){var e=Object(o.useState)(!1),a=l()(e,2),n=a[0],t=a[1];return Object(o.useEffect)((function(){return window.addEventListener("scroll",(function(){return window.pageYOffset>0?t(!0):t(!1)}))}),[]),c.a.createElement(r.a,null,c.a.createElement("header",{className:"whiteBackground"},c.a.createElement(u.i,null,c.a.createElement("h1",null,c.a.createElement("div",null,c.a.createElement("strong",null,"@7urtle"),"/lambda"),"Managing side effects with monads in JavaScript"))),c.a.createElement("article",{className:"whiteBackground textLeft pb6 plr1"},c.a.createElement(u.i,null,c.a.createElement(u.t,null,c.a.createElement(u.g,{md:"3",className:"LearnSideMenu d-none d-md-block"},c.a.createElement("p",null,c.a.createElement(f.a,{target:p.b.Learn},"â€¹ Learn")),c.a.createElement("h2",{className:"pt-0"},"Managing side effects with monads in JavaScript"),c.a.createElement(d.a,{contents:v,sorted:!1})),c.a.createElement(u.g,null,c.a.createElement("p",null,"Instead of explaining the laws governing ",c.a.createElement("strong",null,"monads")," and explaining that ",c.a.createElement("em",null,"monad is just a monoid in the category of endofunctors"),", we will focus on the practical application of monads with ",c.a.createElement("strong",null,"@7urtle/lambda"),"."),c.a.createElement("p",null,"To simplify things you can understand monads as wrappers that aim to simplify the dealing with ",c.a.createElement("strong",null,"side effects, errors, inputs, outputs, and asynchronous code"),"."),c.a.createElement("p",null,"As you probably know, ",c.a.createElement("strong",null,"functional programming")," is very particular about ",c.a.createElement(f.a,{target:p.b.LambdaBasics},"keeping your functions pure")," dependent only on their inputs and not causing any external effects. But real life usually requires your code to read data from somewhere and then save or display some results. Among side effects, you can count output into console, reading files, updating database, editing DOM, saving data, and so on. For all of these you can use monads."),c.a.createElement("p",null,"In ",c.a.createElement("strong",null,"@7urtle/lambda")," we have ",c.a.createElement("code",null,"Maybe"),", ",c.a.createElement("code",null,"Either"),", ",c.a.createElement("code",null,"Case"),",",c.a.createElement("code",null,"SyncEffect"),", and ",c.a.createElement("code",null,"AsyncEffect"),". All of these are ",c.a.createElement("strong",null,"functors"),", ",c.a.createElement("strong",null,"monads"),", and ",c.a.createElement("strong",null,"applicatives")," at the same time because they implement methods ",c.a.createElement("strong",null,"map, flatMap, and ap"),"."),c.a.createElement("h3",{className:"pt-2",id:y(v[0].name)},v[0].name),c.a.createElement("p",null,"Every ",c.a.createElement("strong",null,"functor")," has the method ",c.a.createElement("code",null,"map"),". ",c.a.createElement("code",null,"map")," allows you to apply a function on a value that the functor wraps around safely. It's all easier to understand on an example:"),c.a.createElement(m.a,{language:"javascript",code:"import {deepInspect, map} from '@7urtle/lambda';\n\n// we define our own functor Functor\nconst Functor = {\n  of: value => ({\n    value: value,\n    inspect: () => `Functor(${deepInspect(value)})`,\n    map: fn => Functor.of(fn(value))\n  })\n};\n\nconst add1 = a => a + 1;\n\n// we wrap Functor around the value 1\nconst myFunctor = Functor.of(1); // Functor(1)\nmyFunctor.inspect(); // => 'Functor(1)'\n\n// we map the function add1 on the value inside the functor\nconst myFunctorPlus1 = myFunctor.map(add1); // Functor(2)\n\nmyFunctorPlus1.value; // => 2\nmyFunctor.map(a => a + 1).value; // => 2\nmyFunctor.value; // => 1, no mutation\n\n// you can also apply function map on a functor with the same result\nmyFunctorPlus1again = map(add1)(myFunctor);\nmyFunctorPlus1again === myFunctorPlus1; // => true\n\n// it is the same map that we use for arrays\nmap(add1)([1, 2]); // => [2, 3]"}),c.a.createElement("p",null,"Now if you understand the example and how the function ",c.a.createElement("code",null,"map")," works, ",c.a.createElement("strong",null,"you now understand the basics of functors in functional programming"),". Specialized monads then add a special magic to these and you can learn about that later when those are discussed."),c.a.createElement("h3",{className:"pt-2",id:y(v[1].name)},v[1].name),c.a.createElement("p",null,"If you had a function that returns a functor and you mapped the function on a functor, you would end up with a functor inside of a functor. Every ",c.a.createElement("strong",null,"monad")," has the method ",c.a.createElement("code",null,"flatMap"),". ",c.a.createElement("code",null,"flatMap")," allows you to map a function the same as ",c.a.createElement("code",null,"map")," but it expects that the mapped function returns the same type of monad as is the type of the monad that we are mapping it on. It deals with it by flattening the result into a simple value inside of a monad instead of a value in a monad in a monad. Here is an example:"),c.a.createElement(m.a,{language:"javascript",code:"import {deepInspect, flatMap} from '@7urtle/lambda';\n\n// we define our own monad Monad\nconst Monad = {\n  of: value => ({\n    value: value,\n    inspect: () => `Monad(${deepInspect(value)})`,\n    map: fn => Monad.of(fn(value)),\n    flatMap: fn => fn(value)\n  })\n};\n\n// we wrap Monad around the value 1\nconst myMonad = Monad.of(1); // Monad(1)\n\nconst add1Monad = a => Monad.of(a + 1);\n\n// we map the function add1 on the value inside the monad\nmyMonad.map(add1Monad); // Monad(Monad(2));\nconst myMonadPlus1 = myMonad.flatMap(add1Monad); // Monad(2)\n\nmyMonadPlus1.value; // => 2\nmyMonad.value; // => 1, no mutation\n\n// you can also apply function flatMap on a monad with the same result\nmyMonadPlus1again = map(add1Monad)(myMonad);\nmyMonadPlus1again === myMonadPlus1; // => true"}),c.a.createElement("p",null,"Now if you understand the example and how the function ",c.a.createElement("code",null,"flatMap")," works, ",c.a.createElement("strong",null,"you now understand the basics of monads in functional programming"),"."),c.a.createElement("h3",{className:"pt-2",id:y(v[2].name)},v[2].name),c.a.createElement("p",null,"Because in ",c.a.createElement("strong",null,"functional programming")," we also love ",c.a.createElement(f.a,{target:p.b.LambdaBasics},"partial application"),", we have ",c.a.createElement("strong",null,"applicatives")," and their method ",c.a.createElement("code",null,"ap"),". ",c.a.createElement("code",null,"ap")," allows you to map curried functions that require multiple values using ",c.a.createElement("code",null,"map")," and apply those values using ",c.a.createElement("code",null,"ap"),". More in the following example:"),c.a.createElement(m.a,{language:"javascript",code:"import {deepInspect} from '@7urtle/lambda';\n\n// we define our own applicative Applicative\nconst Applicative = {\n  of: value => ({\n    value: value,\n    inspect: () => `Applicative(${deepInspect(value)})`,\n    map: fn => Applicative.of(fn(value)),\n    flatMap: fn => fn(value),\n    ap: f => f.map(value)\n  })\n};\n\n// we wrap Applicative around the value 1\nconst myApplicative = Applicative.of(1); // Applicative(1)\n\nconst add = a => b => a + b;\n\n// we map the function add on the applicative\nconst myApplicativePartial = myApplicative.map(add); // Applicative(1 + b);\nconst myApplicativePlus1 = myApplicativePartial.ap(Applicative.of(1)); // Applicative(2)\nconst myApplicativePlus3 = myApplicativePartial.ap(Applicative.of(3)); // Applicative(4)\n\nmyApplicativePlus1.value; // => 2\nmyApplicative.value; // => 1, no mutation\n\n// you can also apply function flatMap on a monad with the same result\nmyMonadPlus1again = map(add1Monad)(myMonad);\nmyMonadPlus1again === myMonadPlus1; // => true"}),c.a.createElement("p",null,"Now if you understand the example and how the function ",c.a.createElement("code",null,"ap")," works, ",c.a.createElement("strong",null,"you now understand the basics of applicatives in functional programming"),"."),c.a.createElement("p",null,c.a.createElement("strong",null,"@7urtle/lambda")," also gives you functions ",c.a.createElement("strong",null,"liftA2")," and ",c.a.createElement("strong",null,"liftA3")," to simplify writing functions that work with applicatives. It takes a regular function that expects simple values and turns it into a function that supports applicatives:"),c.a.createElement(m.a,{language:"javascript",code:"import {liftA2} from '@7urtle/lambda';\n\nconst add = a => b => a + b;\n\nconst addAp = liftA2(add);\n\nmyResultApplicative = addAp(Applicative.of(2))(Applicative.of(3));\nmyResultApplicative.value; // => 5"}),c.a.createElement("p",null,"Now all that remains is the magic of specific monads in ",c.a.createElement("strong",null,"@7urtle/lambda"),"."),c.a.createElement("h2",{className:"pt-2",id:y(v[3].name)},v[3].name),c.a.createElement("h2",{className:"pt-2",id:y(v[4].name)},v[4].name),c.a.createElement("h2",{className:"pt-2",id:y(v[5].name)},v[5].name),c.a.createElement("h2",{className:"pt-2",id:y(v[6].name)},v[6].name),c.a.createElement("h2",{className:"pt-2",id:y(v[7].name)},v[7].name))))),c.a.createElement(i.a,null),n&&c.a.createElement(s.a,{scrolled:n,setScrolled:t}))}}}]);