(window.webpackJsonp=window.webpackJsonp||[]).push([[5],{497:function(e,t,n){"use strict";n.r(t);var a=n(60),l=n.n(a),o=n(1),r=n.n(o),i=n(5),c=n(27),s=n(29),u=n(44),m=n(103),d=n(39),g=n(6),h=n(11),p=n(51),f=[{name:"Testing pure functions"},{name:"Testing monads"}],E=function(e){return"lambda-"+Object(g.o)(Object(g.t)("-")(/ /g)(e))};t.default=function(){var e=Object(o.useState)(!1),t=l()(e,2),n=t[0],a=t[1];return Object(o.useEffect)((function(){return window.addEventListener("scroll",(function(){return window.pageYOffset>0?a(!0):a(!1)}))}),[]),r.a.createElement(c.a,null,r.a.createElement("header",{className:"whiteBackground"},r.a.createElement(i.i,null,r.a.createElement("h1",null,r.a.createElement("div",null,r.a.createElement("strong",null,"@7urtle"),"/lambda"),"Effortless testing in JavaScript with functional programming"))),r.a.createElement("article",{className:"whiteBackground textLeft pb6 plr1"},r.a.createElement(i.i,null,r.a.createElement(i.t,null,r.a.createElement(i.g,{md:"3",className:"LearnSideMenu d-none d-md-block"},r.a.createElement("p",null,r.a.createElement(p.a,{target:h.b.Learn},"â€¹ Learn")),r.a.createElement("h2",{className:"pt-0"},"Effortless testing in JavaScript with functional programming"),r.a.createElement(d.a,{contents:f,sorted:!1})),r.a.createElement(i.g,null,r.a.createElement("p",null,"Testing code written with ",r.a.createElement("strong",null,"functional programming")," and ",r.a.createElement("strong",null,"@7urtle/lambda")," requires the same testing tools that you are used to. Nothing new to learn. But ",r.a.createElement("strong",null,"functional programming")," makes the practice much easier. In the code examples bellow, we will be using ",r.a.createElement("a",{href:"https://jestjs.io/",title:"Delightful JavaScript Testing"},"Jest")," library but you can use any other that you like."),r.a.createElement("h2",{id:E(f[0].name)},f[0].name),r.a.createElement("p",null,r.a.createElement("strong",null,"Functional programming")," leads you to the creation of simple pure functions that are combined by function composition. Pure functions are simply dependent only on their input without any side effects. You can read more about them in ",r.a.createElement(p.a,{target:h.b.LambdaBasics}),". Common imperative functions often look like this:"),r.a.createElement(u.a,{language:"javascript",code:"let count = 0;\n\nconst badFunction = function () {\n   ++count;\n};"}),r.a.createElement("p",null,r.a.createElement("code",null,"badFunction")," doesn't take any input and it just does things to change external variables. In functional programming it means that it is causing a ",r.a.createElement("strong",null,"side effect"),". That makes the function difficult to test. You always have to mock external dependencies and the function will have different effect depending on the current state of such dependencies. It should be obvious why such code is hard to debug and test. Functional alternative would look like this:"),r.a.createElement(u.a,{language:"javascript",code:"const goodFunction = count => ++count;"}),r.a.createElement("p",null,r.a.createElement("code",null,"goodFunction")," is a simple pure function that increases the value of its input. It will always return the same value for the same input which makes the test also very simple:"),r.a.createElement(u.a,{language:"javascript",code:"test('goodFunction increases its input without side effects.', () => {\n  let count = 1;\n  expect(goodFunction(count)).toBe(2);\n  expect(count).toBe(1);\n});"}),r.a.createElement("p",null,"Some side effects are of course unavoidable. In the end you want your code to change something whether it is a DOM element or a database record. For managing these we use monads."),r.a.createElement("h2",{id:E(f[1].name)},f[1].name),r.a.createElement("p",null,'Monads represent simple wrappers around "dangerous" values and functions and provide safe way of mapping. To understand the difference in testing consider this imperative scenario working with DOM.'),r.a.createElement(u.a,{language:"javascript",code:"const getHeight = function (element) {\n  return document.querySelector(element).clientHeight;\n};\n\ngetHeight('#myelement');"}),r.a.createElement("p",null,"Working with DOM in JavaScript causes side effects.",r.a.createElement("code",null,"querySelector")," may not find any element and return undefined which will result in a thrown error. To handle this we need to add conditions and/or try catch statements. Now to test this code, you would need  understand well how everything behaves. In a function programming, just use ",r.a.createElement("strong",null,"Maybe")," monad:"),r.a.createElement(u.a,{language:"javascript",code:"import {Maybe} from '@7urtle/lambda';\n\nconst getHeightMaybe = element => Maybe.of(document.querySelector(element)).map(a => a.clientHeight);\n\ngetHeightMaybe('#myelement');"}),r.a.createElement("p",null,r.a.createElement("code",null,"getHeight")," now returns our ",r.a.createElement("strong",null,"Maybe")," monad. Mocking DOM when you are testing DOM is not avoidable but because"))))),r.a.createElement(s.a,null),n&&r.a.createElement(m.a,{scrolled:n,setScrolled:a}))}}}]);