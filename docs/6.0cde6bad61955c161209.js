(window.webpackJsonp=window.webpackJsonp||[]).push([[6],{499:function(e,t,n){"use strict";n.r(t);var a=n(54),o=n.n(a),r=n(1),i=n.n(r),l=n(4),s=n(27),c=n(29),u=n(34),m=n(104),d=n(42),p=n(11),f=n(40),h=n(22),g=n(62),y=[{name:"Testing pure functions"},{name:"Testing with monads"},{name:"Separation of concerns"}],E=function(e){return"lambda-"+Object(h.c)(e)};t.default=function(){var e=Object(r.useState)(!1),t=o()(e,2),n=t[0],a=t[1];return Object(r.useEffect)((function(){return window.addEventListener("scroll",(function(){return window.pageYOffset>0?a(!0):a(!1)}))}),[]),i.a.createElement(s.a,null,i.a.createElement("header",{className:"whiteBackground"},i.a.createElement(l.i,null,i.a.createElement("h1",null,i.a.createElement("div",null,i.a.createElement("strong",null,"@7urtle"),"/lambda"),"Effortless testing in JavaScript with functional programming"))),i.a.createElement("article",{className:"whiteBackground textLeft pb6 plr1"},i.a.createElement(l.i,null,i.a.createElement(l.t,null,i.a.createElement(l.g,{md:"3",className:"LearnSideMenu d-none d-md-block"},i.a.createElement("p",null,i.a.createElement(f.a,{target:p.b.Learn},"â€¹ Learn")),i.a.createElement("h2",{className:"pt-0"},"Effortless testing in JavaScript with functional programming"),i.a.createElement(d.a,{contents:y,sorted:!1})),i.a.createElement(l.g,null,i.a.createElement("p",null,"Testing code written with ",i.a.createElement("strong",null,"functional programming")," and ",i.a.createElement("strong",null,"@7urtle/lambda")," requires the same testing tools that you are used to. Nothing new to learn. But ",i.a.createElement("strong",null,"functional programming")," makes the practice much easier. In the code examples bellow, we will be using ",i.a.createElement("a",{href:"https://jestjs.io/",title:"Delightful JavaScript Testing"},"Jest")," library but you can use any other that you like."),i.a.createElement("h2",{className:"pt-2",id:E(y[0].name)},y[0].name),i.a.createElement("p",null,i.a.createElement("strong",null,"Functional programming")," leads you to the creation of simple pure functions that are stringed together by function composition. Pure functions are simply dependent only on their input without any side effects. You can read more about them in ",i.a.createElement(f.a,{target:p.b.LambdaBasics}),". Common imperative functions often look like this:"),i.a.createElement(u.a,{language:"javascript",code:"let count = 0;\n\nconst badFunction = function () {\n   ++count;\n};"}),i.a.createElement("p",null,i.a.createElement("code",null,"badFunction")," doesn't take any input and it just does things to change external variables. In functional programming that means that it is causing a ",i.a.createElement("strong",null,"side effect"),". That makes the function difficult to test. You always have to mock external dependencies and the function will have different effect depending on the current state of such dependencies. It should be obvious why large code base built this way would be hard to debug. Functional alternative would look like this:"),i.a.createElement(u.a,{language:"javascript",code:"const goodFunction = count => ++count;"}),i.a.createElement("p",null,i.a.createElement("code",null,"goodFunction")," is a simple pure function that increases the value of its input. It will always return the same value for the same input which makes the test also very simple:"),i.a.createElement(u.a,{language:"javascript",code:"test('goodFunction increases its input without side effects.', () => {\n  let count = 1;\n  expect(goodFunction(count)).toBe(2);\n  expect(count).toBe(1);\n});"}),i.a.createElement("p",null,"Some side effects are of course unavoidable. In the end you want your code to change something whether it is a DOM element or a database record. For managing these we use monads."),i.a.createElement("h2",{className:"pt-2",id:E(y[1].name)},y[1].name),i.a.createElement("p",null,'Monads represent simple wrappers around "dangerous" values and functions and provide safe way of mapping. You can find more about monads here: ',i.a.createElement(f.a,{target:p.b.Monads}),". To understand it more, consider this imperative function:"),i.a.createElement(u.a,{language:"javascript",code:"const getHeight = function (element) {\n  return document.querySelector(element).clientHeight;\n};\n\ngetHeight('#myelement');"}),i.a.createElement("p",null,"Coding with DOM in JavaScript is an example of working with side effects. ",i.a.createElement("code",null,"querySelector")," may not find any element and return undefined which will result in the above code throwing an error. To handle this we need to add conditions and/or try catch statements."),i.a.createElement("p",null,"In functional programming, just use ",i.a.createElement("strong",null,"Maybe")," monad as an argument for your function:"),i.a.createElement(u.a,{language:"javascript",code:"import {Maybe, map} from '@7urtle/lambda';\n\nconst selectDOMMaybe = selector => Maybe.of(document.querySelector(selector));\nconst getHeightMaybe = DOMMaybe => map(a => a.clientHeight)(DOMMaybe);\n\ngetHeightMaybe(selectDOMMaybe('#myelement')));"}),i.a.createElement("p",null,i.a.createElement("code",null,"selectDOMMaybe")," and ",i.a.createElement("code",null,"getHeightMaybe")," now work with our ",i.a.createElement("strong",null,"Maybe")," monad. You need to test ",i.a.createElement("code",null,"selectDOMMaybe")," with DOM mock but any following function in the composition like ",i.a.createElement("code",null,"getHeightMaybe")," can be tested independently now and very easily. These two functions also nicely demonstrate the benefit of ",i.a.createElement("strong",null,"separation of concerns")," that is discussed in detail in a moment."),i.a.createElement("p",null,i.a.createElement("code",null,"getHeightMaybe")," can be tested without mocking DOM:"),i.a.createElement(u.a,{language:"javascript",code:"test('getHeightMaybe returns height if DOM element exists.', () => {\n  const mockJust = Maybe.of({clientHeight: 30});\n  const resultJust = getHeightMaybe(mockJust);\n  expect(resultJust.isJust()).toBe(true);\n  expect(resultJust.value).toBe(30);\n});\n\ntest('getHeightMaybe is Nothing if DOM element is undefined.', () => {\n  const mockNothing = Maybe.of(undefined);\n  const resultNothing = getHeightMaybe(mockNothing);\n  expect(resultNothing.isNothing()).toBe(true);\n});"}),i.a.createElement("p",null,"Separation of concerns is another important programming principle that we can apply with ease."),i.a.createElement("h2",{className:"pt-2",id:E(y[2].name)},y[2].name),i.a.createElement("p",null,i.a.createElement("strong",null,"Separation of concerns principle simply tells us to separate parts of code that deal with different things.")," In ",i.a.createElement("strong",null,"functional programming")," when you start learning the basics of pure functions you still need to learn how too deal with side effects."),i.a.createElement("p",null,i.a.createElement("strong",null,"Side effects are inevitable")," when you are integrating your code with the external world. That usually happens twice. At the beginning you need to get the input for your program and at the end yoo need to publish the result. By this logic we can separate our code into two concerns. Integration concern deals with reading and publishing changes and execution concern then deals with transformation of the input into the output."),i.a.createElement("p",null,"In practice your code then should be divided into modules based on separation of concerns as well. Integrations should be tested by integration tests and execution can be covered by regular unit tests. In a code it could be expressed like this:"),i.a.createElement(u.a,{language:"javascript",code:"// ./FileReader.js //////\nimport {fs} from 'fs';\nimport {AsyncEffect} from '@7urtle/lambda';\n\n// readFile :: string -> AsyncEffect\nexport const readFile => input =>\n  AsyncEffect\n  .of(reject => resolve => _ =>\n    fs.readFile(input, (err, data) =>\n      err ? reject(err) : resolve(data)\n    )\n  );\n\n// ./DataTransform.js //////\nimport {UpperCaseOf, trim, compose, map} from '@7urtle/lambda';\n\n// transformer :: string -> string\nexport const transformer = compose(upperCaseOf, trim);\n\n// transformData :: AsyncEffect -> AsyncEffect\nexport const transformData = map(transformer);\n  \n// ./FileWriter.js //////\nimport {fs} from 'fs';\nimport {AsyncEffect, flatMap} from '@7urtle/lambda';\n\n// writeFile :: string -> AsyncEffect -> AsyncEffect\nexport const writeFile = output =>\n  flatMap(data =>\n    AsyncEffect\n    .of(reject => resolve => _ =>\n      fs.writeFile(output, data, error =>\n        error ? reject(error) : resolve('success')\n      )\n    )\n  );\n\n// ./index.js //////\nimport {log, compose} from '@7urtle/lambda';\nimport {readFile} from './FileReader';\nimport {transformData} from './DataTransform';\nimport {writeFile} from './FileWriter';\n\n// execute :: string -> string -> AsyncEffect\nconst execute = input => output => compose(writeFile(output), transformData, readFile)(input);\n\nexecute('input.txt')('output.txt').trigger(log)(log)();"}),i.a.createElement("p",null,"We end up with relatively short code that is divided into four files (modules). Everything is brought together in a final functional composition ",i.a.createElement("code",null,"const execute = input => output => compose(writeFile(output), transformData, readFile)(input);"),"."),i.a.createElement("p",null,"Reading and writing into files is separated into individual modules that handle these side effects and the rest of the code (here simplified into ",i.a.createElement("code",null,"transformData"),") is then pure and easy to test without any mocking like this:"),i.a.createElement(u.a,{language:"javascript",code:"import {AsyncEffect} from '@7urtle/lambda';\nimport {transformer, transformData} from './DataTransform';\n\ntest('transformer input goes through trim and upperCaseOf.', () => {\n  expect(transformer('input')).toBe('INPUT');\n  expect(transformer(' input ')).toBe('INPUT');\n});\n\ntest('transformData maps transformer to AsyncEffect.', done => {\n  const input = AsyncEffect.of(reject => resolve => value => resolve(' input '));\n  \n  transformData(input)\n  .trigger\n  (a => a)\n  (result => {\n    expect(result).toBe('INPUT');\n    done();\n  })\n  ();\n});"}),i.a.createElement("p",null,"Notice that in the test we are happy to verify just the happy path of the AsyncEffect in the final function. We don't need to worry about error states because that is abstracted by the monads."),i.a.createElement("p",null,"It is also important to mention that performance of execution can then be effortlessly optimized by caching ",i.a.createElement(f.a,{target:p.b.Advantages},"memoization"),"."),i.a.createElement("p",null,"The ",i.a.createElement(f.a,{target:p.b.Documentation},"documentation page")," on this website is generated out of JSDoc directly from the source code of ",i.a.createElement("strong",null,"@7urtle/lambda")," and the program uses the separation of concerns principle as it is described here when working with input files and the final output."),i.a.createElement(g.a,null))))),i.a.createElement(c.a,null),n&&i.a.createElement(m.a,{scrolled:n,setScrolled:a}))}}}]);