{"version":3,"sources":["webpack://lambda/webpack/universalModuleDefinition","webpack://lambda/webpack/bootstrap","webpack://lambda/./node_modules/@babel/runtime/helpers/classCallCheck.js","webpack://lambda/./node_modules/@babel/runtime/helpers/createClass.js","webpack://lambda/./node_modules/@babel/runtime/helpers/inherits.js","webpack://lambda/./node_modules/@babel/runtime/helpers/getPrototypeOf.js","webpack://lambda/./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js","webpack://lambda/./node_modules/@babel/runtime/helpers/typeof.js","webpack://lambda/./node_modules/@babel/runtime/helpers/defineProperty.js","webpack://lambda/./node_modules/@babel/runtime/helpers/setPrototypeOf.js","webpack://lambda/./node_modules/@babel/runtime/helpers/assertThisInitialized.js","webpack://lambda/./src/arity.js","webpack://lambda/./src/conditional.js","webpack://lambda/./src/utils.js","webpack://lambda/./src/list.js","webpack://lambda/./src/core.js","webpack://lambda/./src/string.js","webpack://lambda/./src/Case.js","webpack://lambda/./src/Maybe.js","webpack://lambda/./src/Either.js","webpack://lambda/./src/SyncEffect.js","webpack://lambda/./src/AsyncEffect.js"],"names":["root","factory","exports","module","define","amd","this","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","instance","Constructor","TypeError","_defineProperties","target","props","length","descriptor","configurable","writable","protoProps","staticProps","setPrototypeOf","subClass","superClass","constructor","_getPrototypeOf","getPrototypeOf","__proto__","_typeof","assertThisInitialized","self","obj","iterator","_setPrototypeOf","ReferenceError","nary","fn","args","reduce","accumulator","current","isEqual","a","b","isNotEqual","isTrue","isFalse","isGreaterThan","isLessThan","isAtLeast","isAtMost","isTypeOf","typeOf","isString","isBoolean","isNull","isUndefined","isNumber","isObject","isArray","Array","isFunction","isLength","lengthOf","isNotLength","isEmpty","isNotEmpty","isZero","isNotZero","isNothing","isJust","passThrough","f","log","console","spy","deepInspect","minusOneToUndefined","undefined","inspectFunction","String","inspectArray","join","map","inspectString","inspectObject","inspect","k","keysOf","initial","reducer","list","reduceRight","mapper","filter","checker","find","findIndex","separator","keys","entriesOf","entries","everyOf","every","slice","end","start","someOf","some","identity","compose","fns","v","pipe","functorMap","functor","functorFlatMap","flatMap","liftA2","ap1","ap2","ap","liftA3","ap3","concat","includes","indexOf","lastIndexOf","memoize","memory","trim","string","testRegEx","regex","test","substr","limit","startsWith","substring","endsWith","repeat","count","replace","replacement","search","split","lowerCaseOf","toLowerCase","upperCaseOf","toUpperCase","Case","x","match","Map","Maybe","Nothing","Just","of","maybe","error","onJust","functorMaybe","Either","Right","Left","e","message","either","onLeft","onRight","functorEither","isLeft","SyncEffect","trigger","AsyncEffect","reject","resolve","Promise","_"],"mappings":"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","file":"lambda.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"lambda\"] = factory();\n\telse\n\t\troot[\"lambda\"] = factory();\n})(this, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 9);\n","function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nmodule.exports = _classCallCheck;","function _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nmodule.exports = _createClass;","var setPrototypeOf = require(\"./setPrototypeOf\");\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) setPrototypeOf(subClass, superClass);\n}\n\nmodule.exports = _inherits;","function _getPrototypeOf(o) {\n  module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nmodule.exports = _getPrototypeOf;","var _typeof = require(\"../helpers/typeof\");\n\nvar assertThisInitialized = require(\"./assertThisInitialized\");\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return assertThisInitialized(self);\n}\n\nmodule.exports = _possibleConstructorReturn;","function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    module.exports = _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    module.exports = _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nmodule.exports = _typeof;","function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nmodule.exports = _defineProperty;","function _setPrototypeOf(o, p) {\n  module.exports = _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nmodule.exports = _setPrototypeOf;","function _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nmodule.exports = _assertThisInitialized;","/**\r\n * nary takes input of a curried function and allows it to be called both as curried and n-ary.\r\n *\r\n * @pure\r\n * @function\r\n * @HindleyMilner nary :: function a -> function b\r\n * @param {function} fn\r\n * @returns {function}\r\n */\r\nexport const nary = fn =>\r\n    (...args) => args.length === 0\r\n        ? fn()\r\n        : args.reduce((accumulator, current) => accumulator(current), fn);","import {typeOf, lengthOf} from \"./utils\";\nimport {nary} from \"./arity\";\n\n/**\n * isEqual :: a -> b -> boolean\n *\n * isEqual output is true if strict equality between a and b is true.\n * isEqual output is always false for comparison of objects and arrays.\n */\nexport const isEqual = nary(a => b => a === b);\n\n/**\n * isNotEqual :: a -> b -> boolean\n *\n * isNotEqual output is true if strict equality between a and b is false.\n * isNotEqual output is always true for comparison of objects and arrays.\n */\nexport const isNotEqual = nary(a => b => a !== b);\n\n/**\n * isTrue :: a -> boolean\n *\n * isTrue output is true if input is true.\n */\nexport const isTrue = isEqual(true);\n\n/**\n * isFalse :: a -> Boolean\n *\n * isFalse output is true if input is false.\n */\nexport const isFalse = isEqual(false);\n\n/**\n * isGreaterThan :: a -> b -> boolean\n *\n * isGreaterThan output is true if b is greater than a.\n */\nexport const isGreaterThan = nary(a => b => b > a);\n\n/**\n * isLessThan :: a -> b -> boolean\n *\n * isLessThan output is true if b is less than a.\n */\nexport const isLessThan = nary(a => b => b < a);\n\n/**\n * isAtLeast :: a -> b -> boolean\n *\n * isAtLeast output is true if b is greater or equal to a.\n */\nexport const isAtLeast = nary(a => b => b >= a);\n\n/**\n * isAtMost :: a -> b -> boolean\n *\n * isAtMost output is true if b is less or equal to a.\n */\nexport const isAtMost = nary(a => b => b <= a);\n\n/**\n * isTypeOf :: a -> b -> boolean\n *\n * isTypeOf output is true if b is a type of a.\n */\nexport const isTypeOf = nary(a => b => isEqual(typeOf(b))(a));\n\n/**\n * isString :: a -> boolean\n *\n * isString output is true if b is a string.\n */\nexport const isString = isTypeOf('string');\n\n/**\n * isBoolean :: a -> boolean\n *\n * isBoolean output is true if b is a boolean.\n */\nexport const isBoolean = isTypeOf('boolean');\n\n/**\n * isNull :: a -> boolean\n *\n * isNull output is true if b is a null.\n */\nexport const isNull = isEqual(null);\n\n/**\n * isUndefined :: a -> boolean\n *\n * isUndefined output is true if b is an undefined.\n */\nexport const isUndefined = isTypeOf('undefined');\n\n/**\n * isNumber :: a -> boolean\n *\n * isNumber output is true if b is a number.\n */\nexport const isNumber = isTypeOf('number');\n\n/**\n * isObject :: a -> boolean\n *\n * isObject output is true if b is an object, array of null.\n */\nexport const isObject = isTypeOf('object');\n\n/**\n * isArray :: a -> boolean\n *\n * isArray output is true if b is an array.\n */\nexport const isArray = Array.isArray;\n\n/**\n * isFunction :: a -> boolean\n *\n * isFunction output is true if b is a function.\n */\nexport const isFunction = isTypeOf('function');\n\n/**\n * isLength :: (string|array) -> b -> boolean\n *\n * isLength output is true if b is a length of a.\n */\nexport const isLength = nary(a => b => isEqual(lengthOf(b))(a));\n\n/**\n * isNotLength :: (string|array) -> b -> boolean\n *\n * isNotLength output is true if b is not a length of a.\n */\nexport const isNotLength = nary(a => b => !isLength(a)(b));\n\n/**\n * isEmpty :: (string|array) -> boolean\n *\n * isEmpty output is true if input has a length of 0.\n * isEmpty output is always false if input is an object and not an array or a string.\n */\nexport const isEmpty = isLength(0);\n\n/**\n * isNotEmpty :: (string|array) -> boolean\n *\n * isNotEmpty output is true if input does not have a length of 0.\n * isNotEmpty output is always true if input is an object and not an array or a string.\n */\nexport const isNotEmpty = isNotLength(0);\n\n/**\n * isZero :: a -> boolean\n *\n * isZero output is true if a is 0.\n */\nexport const isZero = isEqual(0);\n\n/**\n * isNotZero :: a -> boolean\n *\n * isNotZero output is true if a is not 0.\n */\nexport const isNotZero = isNotEqual(0);\n\n/**\n * isNothing :: a -> boolean\n *\n * isNothing returns true if input is null, undefined or empty string or empty array.\n */\nexport const isNothing = a => isNull(a) || isUndefined(a) || isEmpty(a);\n\n/**\n * isJust :: a -> boolean\n *\n * isJust returns true if input is not null, undefined or empty string or empty array.\n */\nexport const isJust = a => !isNothing(a);","import {isArray, isEqual, isString, isObject, isFunction, isNull, isUndefined, isGreaterThan} from \"./conditional\";\nimport {keysOf, join, map} from \"./list\";\nimport {nary} from \"./arity\";\n\n/**\n * typeOf :: a -> string\n *\n * typeOf outputs type of its input a.\n */\nexport const typeOf = a => typeof a;\n\n/**\n * lengthOf :: (string|array) -> number\n *\n * lenghtOf outputs the length of an input.\n */\nexport const lengthOf = a => a.length;\n\n/**\n * passThrough :: function -> a -> a\n *\n * passThrough output is the same as input a.\n * passThrough executes function passed as first argument.\n */\nexport const passThrough = nary(f => a => {\n  f(a);\n  return a;\n});\n\n/**\n * log :: a -> a\n *\n * log output is the same as input.\n * log causes side effect of console.log.\n */\nexport const log = passThrough(console.log);\n\n/**\n * spy :: a -> a\n *\n * spy output is the same as input.\n * spy causes side effect of console.log.\n */\nexport const spy = passThrough(a => console.log(deepInspect(a)));\n\n/**\n * minusOneToUndefined :: a -> a|boolean\n *\n * minusOneToUndefined output is the same as input or undefined if input is -1.\n */\nexport const minusOneToUndefined = a => isEqual(-1)(a) ? undefined: a;\n\n/**\n * inspectFunction :: (a -> b) -> string\n *\n * inspectFunction outputs name of named function or its conversion to string.\n */\nexport const inspectFunction = f => f.name ? f.name : String(f);\n\n/**\n * inspectArray :: [a] -> string\n *\n * inspectArray maps over input array [a] and outputs string representing it.\n */\nexport const inspectArray = a => `[${join(', ')(map(deepInspect)(a))}]`;\n\n/**\n * inspectString :: a -> string\n *\n * inspectString outputs string representing input.\n */\nexport const inspectString = a => `'${a}'`;\n\n/**\n * inspectObject :: a -> string\n *\n * inspectObject outputs string representing input.\n */\nexport const inspectObject = a =>\n  isFunction(a.inspect)\n    ? a.inspect()\n    : `{${join(', ')(map(join(': '))(map(k => [k, deepInspect(a[k])])(keysOf(a))))}}`\n\n/**\n * deepInspect :: a -> string\n *\n * deepInspect runs recursively over input and outputs string representing the input.\n */\nexport const deepInspect = a =>\n  isUndefined(a)\n    ? 'undefined'\n    : isNull(a)\n      ? 'null'\n      : isFunction(a)\n        ? inspectFunction(a)\n        : isArray(a)\n          ? inspectArray(a)\n          : isObject(a)\n            ? inspectObject(a)\n            : isString(a)\n              ? inspectString(a)\n              : String(a);","import {minusOneToUndefined} from './utils';\nimport {nary} from \"./arity\";\n\n/**\n * reduce :: a -> ((a, b) -> a) -> [b] -> a\n *\n * reduce executes input reducer function that over each member of input array [b] to output single value a.\n *\n * reduce executes functions in reverse order to reduceRight.\n */\nexport const reduce = nary(initial => reducer => list => list.reduce(reducer, initial));\n\n/**\n * reduceRight :: a -> ((a, b) -> a) -> [b] -> a\n *\n * reduceRight executes input reducer function that over each member of input array [b] to output single value a.\n *\n * reduceRight executes functions in reverse order to reduce.\n */\nexport const reduceRight = nary(initial => reducer => list => list.reduceRight(reducer, initial));\n\n/**\n * map :: (a -> b) -> [a] -> [b]\n *\n * map executes input mapper over each member of input array [a] to output new array [b].\n */\nexport const map = nary(mapper => list => list.map(mapper));\n\n/**\n * filter :: (a -> boolean) -> [a] -> [b]\n *\n * filter executes input checker over each member of input array [a] to filter and output filtered new array [b].\n */\nexport const filter = nary(checker => list => list.filter(checker));\n\n/**\n * find :: (a -> boolean) -> [a] -> [b]\n *\n * find executes input checker over each member of input array [a] and outputs the first array member that matches checker or undefined.\n */\nexport const find = nary(checker => list => list.find(checker));\n\n/**\n * findIndex :: (a -> boolean) -> [a] -> [b]\n *\n * findIndex executes input checker over each member of input array [a] and outputs the index of first array member that matches checker or undefined.\n */\nexport const findIndex = nary(checker => list => minusOneToUndefined(list.findIndex(checker)));\n\n/**\n * join :: string -> [a] -> string\n *\n * join outputs a string created by joining input array members with input separator.\n */\nexport const join = nary(separator => list => list.join(separator));\n\n/**\n * keysOf :: object -> [string]\n *\n * keysOf outputs array of string keys of input array or object.\n */\nexport const keysOf = Object.keys;\n\n/**\n * entriesOf :: object -> [[string, a]]\n *\n * entriesOf outputs array of arrays of string keys and raw values of input array or object.\n */\nexport const entriesOf = Object.entries;\n\n/**\n * everyOf :: (a -> boolean) -> [a] -> boolean\n *\n * everyOf outputs true if every element of input array passes input checker function as true.\n */\nexport const everyOf = nary(checker => list => list.every(checker));\n\n/**\n * slice :: number -> number -> [a] -> [a]\n *\n * slice outputs selected array elements as an array based on input range.\n */\nexport const slice = nary(end => start => list => list.slice(start, end));\n\n/**\n * some :: (a -> boolean) -> [a] -> boolean\n *\n * some outputs true if any element of input array passes input checker function as true.\n */\nexport const someOf = nary(checker => list => list.some(checker));","import {reduce, reduceRight} from './list';\nimport {isString, isArray, isObject} from './conditional';\nimport {minusOneToUndefined, passThrough} from './utils';\nimport {nary} from \"./arity\";\n\n/**\n * identity simply passes its input to its output.\n *\n * @HindleyMilner identity :: a -> a\n *\n * @pure\n * @param {*} a\n * @return {a}\n *\n * @example\n * identity('anything');\n * // => anything\n */\nexport const identity = a => a;\n\n/**\n * pipe output is a right-to-left function composition\n * where each function receives input and hands over its output to the next function.\n *\n * compose executes functions in reverse order to pipe.\n *\n * compose(f,g)(x) is equivalent to f(g(x)).\n *\n * @HindleyMilner compose :: [(a -> b)] -> a -> (a -> b)\n *\n * @pure\n * @param {function} fns\n * @param {*} a\n * @return {*}\n *\n * @example\n * const addA = a => a + 'A';\n * const addB = a => a + 'B';\n * const addAB = compose(addB, addA);\n *\n * addAB('Order: ');\n * // => Order: AB\n */\nexport const compose = (...fns) => a => reduceRight(a)((v, f) => f(v))(fns);\n\n/**\n * pipe :: [(a -> b)] -> a -> (a -> b)\n *\n * pipe output is a left-to-right function composition\n * where each function receives input and hands over its output to the next function.\n *\n * pipe executes functions in reverse order to compose.\n *\n * pipe(f,g)(x) is equivalent to g(f(x)).\n */\nexport const pipe = (...fns) => a => reduce(a)((v, f) => f(v))(fns);\n\n/**\n * functorMap :: (a -> b) -> Functor -> Functor\n *\n * functorMap maps function over inputted functor outputting resulting functor.\n */\nexport const functorMap = nary(fn => functor => functor.map(fn));\n\n/**\n * functorFlatMap :: (a -> Functor) -> Functor -> Functor\n *\n * functorFlatMap flatMaps function outputting functor over inputted functor outputting resulting functor.\n */\nexport const functorFlatMap = nary(fn => functor => functor.flatMap(fn));\n\n/**\n * liftA2 (a -> b -> c) -> Applicative a -> Applicative b -> Applicative c\n *\n * liftA2 provides point-free way of writing calls over applicative functors and functions with arity 2.\n */\nexport const liftA2 = nary(fn => ap1 => ap2 => ap1.map(fn).ap(ap2));\n\n/**\n * liftA3 (a -> b -> c -> d) -> Applicative a -> Applicative b -> Applicative c -> Applicative d\n *\n * liftA3 provides point-free way of writing calls over applicative functors and functions with arity 3.\n */\nexport const liftA3 = nary(fn => ap1 => ap2 => ap3 => ap1.map(fn).ap(ap2).ap(ap3));\n\n/**\n * concat :: a -> a|boolean\n * \n * contact outputs concatenated inputs of strings, arrays and objects or outputs undefined for other types.\n */\nexport const concat = nary(a => b =>\n  isString(b) || isArray(b)\n    ? b.concat(a)\n    : isObject(b)\n      ? {...b, ...a}\n      : undefined);\n\n/**\n * includes :: a -> b -> boolean\n *\n * includes output is true if b includes a.\n */\nexport const includes = nary(a => b => b.includes(a));\n\n/**\n * indexOf :: a -> b -> number\n * \n * indexOf outputs position of input a within input b or undefined if it is not found.\n */\nexport const indexOf = nary(a => b => minusOneToUndefined(b.indexOf(a)));\n\n/**\n * lastIndexOf :: a -> b -> number\n * \n * lastIndexOf outputs position of input a withing input b looking from the end or it retuns undefined if it is not found.\n */\nexport const lastIndexOf = nary(a => b => minusOneToUndefined(b.lastIndexOf(a)));\n\n/**\n * memoize :: object -> (a -> b) -> a -> b\n *\n * memoize uses input memory to save output of input function and then uses it to lookup result on a repeated run\n */\nexport const memoize = nary(memory => fn => a =>\n  a in memory ? memory[a] : (passThrough(b => memory[a] = b))(fn(a)));","import {minusOneToUndefined} from './utils';\nimport {nary} from \"./arity\";\n\n/**\n * trim :: string -> string\n *\n * trim output is a string without white characters around it.\n */\nexport const trim = string => string.trim();\n\n/**\n * testRegEx :: regex -> string -> boolean\n *\n * testRegEx outputs true if string b passes regular expression a.\n */\nexport const testRegEx = nary(regex => string => regex.test(string));\n\n/**\n * substr :: number -> number -> string -> string\n * \n * substr outputs substring based on provided string, start and limit.\n */\nexport const substr = nary(limit => start => string => string.substr(start, limit));\n\n/**\n * startsWith :: string -> string -> boolean\n * \n * startsWith outputs true if an input string starts with provided string.\n */\nexport const startsWith = nary(substring => string => string.startsWith(substring));\n\n/**\n * endsWith :: string -> string -> boolean\n * \n * endsWith outputs true if an input string ends with provided string.\n */\nexport const endsWith = nary(substring => string => string.endsWith(substring));\n\n/**\n * repeat :: number -> string -> string\n * \n * repeat outputs new string repeating input string inputed count of times.\n */\nexport const repeat = nary(count => string => string.repeat(count));\n\n/**\n * replace :: string -> string -> string -> string\n * \n * replace outputs new string replacing input substring with input replacement string in input string.\n */\nexport const replace = nary(replacement => substring => string => string.replace(substring, replacement));\n\n/**\n * search :: string/regex -> string -> number\n * \n * search outputs position of input substring or regular expression withing input string or undefined if it is not found.\n */\nexport const search = nary(substring => string => minusOneToUndefined(string.search(substring)));\n\n/**\n * split :: string -> string -> array\n * \n * split outputs and array of an input string split by the input substring.\n */\nexport const split = nary(substring => string => string.split(substring));\n\n/**\n * lowerCaseOf :: string -> string\n * \n * lowerCaseOf ouputs the lower case version of input string.\n */\nexport const lowerCaseOf = string => string.toLowerCase();\n\n/**\n * upperCaseOf :: string -> string\n * \n * upperCaseOf ouputs the upper case version of input string.\n */\nexport const upperCaseOf = string => string.toUpperCase();","import {deepInspect} from \"./utils\";\n\n/**\n * Case.of() outputs instance of Case.\n * Case.of([]).inspect() outputs string Case(a -> b).\n * Case.of([]).match(a) matches input a against map provided as input of Case.\n * Case.of([]).match(a) outputs undefined if no matching case is found.\n * Case.of([]).map(a -> b) composes function over Case match function.\n * Case.of([]).map(a -> Case) outputs Case(Case).\n * Case.of([]).flatMap(a -> Case) outputs Case.\n */\nexport class Case {\n  constructor(x) {\n    this.match = x;\n  }\n\n  inspect() {\n    return `Case(${deepInspect(this.match)})`;\n  }\n\n  static of(x) {\n    return new Case(\n      (x => a => x.get(a) || x.get('_') || undefined)(new Map(x))\n    );\n  }\n\n  map(fn) {\n    return new Case(a => fn(this.match(a)));\n  }\n\n  flatMap(fn) {\n    return new Case(a => this.map(fn).match(a).match(a));\n  }\n}","import {deepInspect} from \"./utils\";\nimport {isNothing} from \"./conditional\";\nimport {nary} from \"./arity\";\n\n/**\n * Maybe.of() outputs instance of Maybe.\n * Maybe.of(a).inspect() outputs string Just(a) or Nothing.\n * Maybe.of(a) outputs Nothing for an input that is null, undefined, an empty string or an empty array.\n * Maybe.of(a) outputs Just for an input a that is not Nothing.\n * Maybe.of(a) outputs Nothing for an input a that is null or undefined.\n * Maybe.of(a).isJust() of an input a outputs true for a value that is Just.\n * Maybe.of(a).isNothing() of an input a outputs true for a value that is Nothing.\n * Maybe.of(a).map(a -> b) executes function over Maybe input a.\n * Maybe.of(a).map(a -> Just) outputs Just(Just).\n * Maybe.of(a).map(a -> b) does not execute over Nothing.\n * Maybe.of(a).flatMap(a -> b) executes function over Maybe input a returns its raw value.\n * Maybe.of(a).flatMap(a -> b) does not execute over Nothing.\n * Maybe.of(a).map(a -> b).ap(Maybe) provides applicative ability to apply functors to each other.\n * Maybe.of(Maybe -> Maybe -> c).ap(Maybe).ap(Maybe) provides applicative interface for a functor of a function.\n */\nexport class Maybe {\n  constructor(x) {\n    this.value = x;\n  }\n\n  static of(x) {\n    return isNothing(x) ? new Nothing(x) : new Just(x) ;\n  }\n}\n\nclass Just extends Maybe {\n  inspect() {\n    return `Just(${deepInspect(this.value)})`;\n  }\n\n  isNothing() {\n    return false;\n  }\n\n  isJust() {\n    return true;\n  }\n\n  map(fn) {\n    return Maybe.of(fn(this.value));\n  }\n\n  flatMap(fn) {\n    return fn(this.value);\n  }\n\n  ap(f) {\n    return f.map(this.value);\n  }\n}\n\nclass Nothing extends Maybe {\n  inspect () {\n    return 'Nothing';\n  }\n\n  isNothing() {\n    return true\n  }\n\n  isJust() {\n    return false;\n  }\n\n  map(fn) {\n    return this;\n  }\n\n  flatMap(fn) {\n    return this;\n  }\n\n  ap(f) {\n    return this;\n  }\n}\n\n/**\n * maybe :: a -> (b -> c) -> Maybe\n *\n * maybe outputs result of a function onJust if input Maybe is Just or outputs input error if input Maybe is Nothing.\n */\nexport const maybe = nary(error => onJust => functorMaybe =>\n  functorMaybe.isNothing()\n    ? error\n    : onJust(functorMaybe.value));","import {deepInspect} from \"./utils\";\nimport {nary} from \"./arity\";\n\n/**\n * Either.of() outputs instance of Either.\n * Either.of(a) outputs instance of Right holding its input value.\n * Either.Right(a) outputs instance of Right holding its input value.\n * Either.Left(a) outputs instance of Left holding its input value.\n * Either.of(a).inspect() outputs string Right(a).\n * Either.Right(a).inspect() outputs string Right(a).\n * Either.Left(a).inspect() outputs string Left(a).\n * Either.of(a).isRight() always outputs true.\n * Either.Left(a).isLeft() outputs false if Either is Left.\n * Either.try(a -> b) outputs Right(b) if no error is thrown.\n * Either.try(a -> b) outputs Left(e.message) if error is thrown.\n * Either.of(a).map(a -> b) executes function over Either input a.\n * Either.of(a).map(a -> Right) outputs Right(Right).\n * Either.Left(a).map(a -> b) does not execute provided function and retains Left input value.\n * Either.of(a).flatMap(a -> b) executes function over Either input a returns its raw value through flatten.\n * Either.Left(a).flatMap(a -> b) does not execute provided function and retains Left input value.\n * Either.of(Either -> Either -> c).ap(Either).ap(Either) provides applicative interface.\n */\nexport class Either {\n  constructor(x) {\n    this.value = x;\n  }\n\n  static of(x) {\n    return new Right(x);\n  }\n\n  static Right(x) {\n    return new Right(x);\n  }\n\n  static Left(x) {\n    return new Left(x);\n  }\n\n  static try(fn) {\n    try {\n      return new Right(fn());\n    } catch(e) {\n      return new Left(e.message);\n    }\n  }\n}\n\nclass Right extends Either {\n  inspect() {\n    return `Right(${deepInspect(this.value)})`;\n  }\n\n  isLeft() {\n    return false;\n  }\n\n  isRight() {\n    return true;\n  }\n\n  map(fn) {\n    return Either.of(fn(this.value));\n  }\n\n  flatMap(fn) {\n    return fn(this.value);\n  }\n\n  ap(f) {\n    return f.map(this.value);\n  }\n}\n\nclass Left extends Either {\n  inspect() {\n    return `Left(${deepInspect(this.value)})`;\n  }\n\n  isLeft() {\n    return true;\n  }\n\n  isRight() {\n    return false;\n  }\n\n  map() {\n    return this;\n  }\n\n  flatMap() {\n    return this;\n  }\n\n  ap() {\n    return this;\n  }\n}\n\n/**\n * either :: (a -> b) -> (b -> c) -> Either\n *\n * either outputs result of a function onRight if input Either is Right or outputs result of a function onLeft if input Either is Left.\n */\nexport const either = nary(onLeft => onRight => functorEither =>\n  functorEither.isLeft()\n    ? onLeft(functorEither.value)\n    : onRight(functorEither.value));","import {deepInspect} from \"./utils\";\n\n/**\n * SyncEffect.of() outputs instance of SyncEffect.\n * SyncEffect.wrap(a) is equal to SyncEffect.of(() -> a).\n * SyncEffect.of(() -> a).inspect() outputs string SyncEffect(a).\n * SyncEffect.of(() -> a).trigger() executes function provided as input of SyncEffect.\n * SyncEffect.of(() -> a).map(b -> c) composes function over SyncEffect input function.\n * SyncEffect.of(() -> a).map(b -> SyncEffect) outputs SyncEffect(SyncEffect).\n * SyncEffect.of(() -> a).flatMap(b -> SyncEffect) outputs SyncEffect.\n * SyncEffect.of(() -> a).map(a -> b).ap(SyncEffect) provides applicative ability to apply functors to each other.\n * SyncEffect.of(SyncEffect -> SyncEffect -> c).ap(SyncEffect).ap(SyncEffect) provides applicative interface for a functor of a function.\n * No input function is executed until trigger is called.\n */\nexport class SyncEffect {\n  constructor(fn) {\n    this.trigger = fn;\n  }\n\n  inspect() {\n    return `SyncEffect(${deepInspect(this.trigger)})`;\n  }\n\n  static of(x) {\n    return new SyncEffect(x);\n  }\n\n  static wrap(x) {\n    return new SyncEffect(() => x);\n  }\n\n  map(fn) {\n    return new SyncEffect(a => fn(this.trigger(a)));\n  }\n\n  flatMap(fn) {\n    return new SyncEffect(() => {\n      return this.map(fn).trigger().trigger();\n    })\n  }\n\n  ap(f) {\n    return this.flatMap(fn => f.map(fn));\n  }\n}","import {deepInspect} from \"./utils\";\n\n/**\n * AsyncEffect.of() outputs instance of AsyncEffect.\n * AsyncEffect.of(() -> a).inspect() outputs string AsyncEffect(a).\n * AsyncEffect.wrap(a) is equal to AsyncEffect.of((_, resolve) -> resolve(a)).\n * AsyncEffect.of((a, b) -> c).promise() outputs JavaScript promise.\n * AsyncEffect.of((a, b) -> c).trigger(d -> e, f -> g) for resolving async function resolves.\n * AsyncEffect.of((a, b) -> c).trigger(d -> e, f -> g) for rejecting async function rejects.\n * AsyncEffect.of((a, b) -> c).trigger(d -> e, f -> g) for synchronous exceptions rejects.\n * AsyncEffect.of((a, b) -> c).map(b -> c) composes function over AsyncEffect input function.\n * AsyncEffect.of((a, b) -> c).map(b -> AsyncEffect) outputs AsyncEffect(AsyncEffect).\n * AsyncEffect.of((a, b) -> c).flatMap(b -> AsyncEffect) outputs AsyncEffect.\n * AsyncEffect.of((a, b) -> c).flatMap(b -> AsyncEffect) handles reject states correctly passing along the initial error.\n * AsyncEffect.of((a, b) -> c).map(a -> b).ap(AsyncEffect) provides applicative ability to apply functors to each other.\n * AsyncEffect.of(AsyncEffect -> AsyncEffect -> c).ap(AsyncEffect).ap(AsyncEffect) provides applicative interface for a functor of a function.\n * No input function is executed until trigger is called.\n */\nexport class AsyncEffect {\n  constructor(fn) {\n    this.trigger = (reject, resolve) => {\n      try { \n        return fn(reject, resolve);\n      } catch(error) {\n        reject(error);\n      }\n    }\n  }\n\n  inspect() {\n    return `AsyncEffect(${deepInspect(this.trigger)})`;\n  }\n\n  static of(x) {\n    return new AsyncEffect(x);\n  }\n\n  static wrap(x) {\n    return new AsyncEffect((_, resolve) => resolve(x));\n  }\n\n  promise() {\n    return new Promise((resolve, reject) => this.trigger(reject, resolve));\n  }\n\n  map(fn) {\n    return new AsyncEffect((reject, resolve) => this.trigger(reject, a => resolve(fn(a))));\n  }\n\n  flatMap(fn) {\n    return new AsyncEffect((reject, resolve) => this.trigger(reject, x => fn(x).trigger(reject, resolve)));\n  }\n\n  ap(f) {\n    return this.flatMap(fn => f.map(fn));\n  }\n}"],"sourceRoot":""}