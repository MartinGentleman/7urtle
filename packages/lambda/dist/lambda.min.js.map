{"version":3,"sources":["webpack://lambda/webpack/universalModuleDefinition","webpack://lambda/webpack/bootstrap","webpack://lambda/./src/list.js","webpack://lambda/./src/core.js","webpack://lambda/./src/conditional.js","webpack://lambda/./src/utils.js","webpack://lambda/./src/string.js","webpack://lambda/./src/maybe.js","webpack://lambda/./src/either.js","webpack://lambda/./src/syncEffect.js","webpack://lambda/./src/index.js"],"names":["root","factory","exports","module","define","amd","this","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","reduce","initial","reducer","list","reduceRight","map","mapper","identity","a","compose","_len","arguments","length","fns","Array","_key","v","f","pipe","_len2","_key2","liftA2","fn","ap1","ap2","ap","liftA3","ap3","isEqual","b","isNotEqual","isTrue","isFalse","isGreaterThan","isLessThan","isAtLeast","isAtMost","isTypeOf","_typeof","isString","isBoolean","isNull","isUndefined","isNumber","isObject","isArray","isFunction","isLength","isNotLength","isEmpty","isNotEmpty","isNothing","isJust","passThrough","log","console","inspectFunction","toString","inspectArray","concat","deepInspect","join","inspectString","inspectObject","inspect","keys","k","kv","String","trim","includes","testRegEx","test","Maybe","x","_classCallCheck","_createClass","Nothing","Just","of","traverse","Either","either_classCallCheck","either_createClass","Right","Left","e","message","syncEffect","syncEffect_classCallCheck","trigger","_this","flatMap","__webpack_exports__","list_map","core_compose","core_pipe","utils_inspectObject","utils_deepInspect","maybe_Maybe","syncEffect_syncEffect"],"mappings":"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","file":"lambda.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"lambda\"] = factory();\n\telse\n\t\troot[\"lambda\"] = factory();\n})(this, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","/**\n * reduce :: a -> ((a, b) -> a) -> [b] -> a\n *\n * reduce executes input reducer function that over each member of input array [b] to output single value a.\n *\n * reduce executes functions in reverse order to reduceRight.\n */\nexport const reduce = initial => reducer => list => list.reduce(reducer, initial);\n\n/**\n * reduceRight :: a -> ((a, b) -> a) -> [b] -> a\n *\n * reduceRight executes input reducer function that over each member of input array [b] to output single value a.\n *\n * reduceRight executes functions in reverse order to reduce.\n */\nexport const reduceRight = initial => reducer => list => list.reduceRight(reducer, initial);\n\n/**\n * map :: (a -> b) -> [a] -> [b]\n *\n * map executes input mapper over each member of input array [a] to output new array [b].\n */\nexport const map = mapper => list => list.map(mapper);","import {reduce, reduceRight} from \"./list\";\n\n/**\n * identity :: a -> a\n *\n * identity output is the same as input.\n */\nexport const identity = a => a;\n\n/**\n * compose :: [(a -> b)] -> a -> (a -> b)\n *\n * compose output is a function composition\n * where each function receives input and hands over its output to the next function.\n *\n * compose executes functions in reverse order to pipe.\n *\n * compose(f,g)(x) is equivalent to f(g(x)).\n */\nexport const compose = (...fns) => a => reduceRight(a)((v, f) => f(v))(fns);\n\n/**\n * pipe :: [(a -> b)] -> a -> (a -> b)\n *\n * pipe output is a function composition\n * where each function receives input and hands over its output to the next function.\n *\n * pipe executes functions in reverse order to compose.\n *\n * pipe(f,g)(x) is equivalent to g(f(x)).\n */\nexport const pipe = (...fns) => a => reduce(a)((v, f) => f(v))(fns);\n\n/**\n * liftA2 (a -> b -> c) -> Applicative a -> Applicative b -> Applicative c\n *\n * liftA2 provides point-free way of writing calls over applicative functors and functions with arity 2.\n */\nexport const liftA2 = fn => ap1 => ap2 => ap1.map(fn).ap(ap2);\n\n/**\n * liftA3 (a -> b -> c -> d) -> Applicative a -> Applicative b -> Applicative c -> Applicative d\n *\n * liftA3 provides point-free way of writing calls over applicative functors and functions with arity 3.\n */\nexport const liftA3 = fn => ap1 => ap2 => ap3 => ap1.map(fn).ap(ap2).ap(ap3);","/**\n * isEqual :: a -> b -> boolean\n *\n * isEqual output is true if strict equality between a and b is true.\n * isEqual output is always false for comparison of objects and arrays.\n */\nexport const isEqual = a => b => a === b;\n\n/**\n * isNotEqual :: a -> b -> boolean\n *\n * isNotEqual output is true if strict equality between a and b is false.\n * isNotEqual output is always true for comparison of objects and arrays.\n */\nexport const isNotEqual = a => b => a !== b;\n\n/**\n * isTrue :: a -> boolean\n *\n * isTrue output is true if input is true.\n */\nexport const isTrue = isEqual(true);\n\n/**\n * isFalse :: a -> Boolean\n *\n * isFalse output is true if input is false.\n */\nexport const isFalse = isEqual(false);\n\n/**\n * isGreaterThan :: a -> b -> boolean\n *\n * isGreaterThan output is true if b is greater than a.\n */\nexport const isGreaterThan = a => b => b > a;\n\n/**\n * isLessThan :: a -> b -> boolean\n *\n * isLessThan output is true if b is less than a.\n */\nexport const isLessThan = a => b => b < a;\n\n/**\n * isAtLeast :: a -> b -> boolean\n *\n * isAtLeast output is true if b is greater or equal to a.\n */\nexport const isAtLeast = a => b => b >= a;\n\n/**\n * isAtMost :: a -> b -> boolean\n *\n * isAtMost output is true if b is less or equal to a.\n */\nexport const isAtMost = a => b => b <= a;\n\n/**\n * isTypeOf :: a -> b -> boolean\n *\n * isTypeOf output is true if b is a type of a.\n */\nexport const isTypeOf = a => b => isEqual(typeof b)(a);\n\n/**\n * isString :: a -> boolean\n *\n * isString output is true if b is a string.\n */\nexport const isString = isTypeOf('string');\n\n/**\n * isBoolean :: a -> boolean\n *\n * isBoolean output is true if b is a boolean.\n */\nexport const isBoolean = isTypeOf('boolean');\n\n/**\n * isNull :: a -> boolean\n *\n * isNull output is true if b is a null.\n */\nexport const isNull = isEqual(null);\n\n/**\n * isUndefined :: a -> boolean\n *\n * isUndefined output is true if b is an undefined.\n */\nexport const isUndefined = isTypeOf('undefined');\n\n/**\n * isNumber :: a -> boolean\n *\n * isNumber output is true if b is a number.\n */\nexport const isNumber = isTypeOf('number');\n\n/**\n * isObject :: a -> boolean\n *\n * isObject output is true if b is an object, array of null.\n */\nexport const isObject = isTypeOf('object');\n\n/**\n * isArray :: a -> boolean\n *\n * isArray output is true if b is an array.\n */\nexport const isArray = Array.isArray;\n\n/**\n * isFunction :: a -> boolean\n *\n * isFunction output is true if b is a function.\n */\nexport const isFunction = isTypeOf('function');\n\n/**\n * isLength :: (string|array) -> b -> boolean\n *\n * isLength output is true if b is a length of a.\n */\nexport const isLength = a => b => isEqual(b.length)(a);\n\n/**\n * isNotLength :: (string|array) -> b -> boolean\n *\n * isNotLength output is true if b is not a length of a.\n */\nexport const isNotLength = a => b => isNotEqual(b.length)(a);\n\n/**\n * isEmpty :: (string|array) -> boolean\n *\n * isEmpty output is true if b is a length of 0.\n * isEmpty output is always false if b is an object and not an array or a string.\n */\nexport const isEmpty = isLength(0);\n\n/**\n * isNotEmpty :: (string|array) -> boolean\n *\n * isNotEmpty output is true if b is not a length of 0.\n * isNotEmpty output is always true if b is an object and not an array or a string.\n */\nexport const isNotEmpty = isNotLength(0);\n\n/**\n * isNothing :: a -> boolean\n *\n * isNothing returns true if input is null, undefined or empty string or empty array.\n */\nexport const isNothing = a => isNull(a) || isUndefined(a) || isEmpty(a);\n\n/**\n * isJust :: a -> boolean\n *\n * isJust returns true if input is not null, undefined or empty string or empty array.\n */\nexport const isJust = a => !isNothing(a);","import {isArray, isString, isObject, isFunction} from \"./conditional\";\n\n/**\n * passThrough :: function -> a -> a\n *\n * passThrough output is the same as input a.\n * passThrough executes function passed as first argument.\n */\nexport const passThrough = f => a => {\n  f(a);\n  return a;\n};\n\n/**\n * log :: a -> a\n *\n * log output is the same as input.\n * log causes side effect of console.log.\n */\nexport const log = passThrough(console.log);\n\n/**\n * inspectFunction :: (a -> b) -> string\n *\n * inspectFunction outputs name of named function or its conversion to string.\n */\nexport const inspectFunction = f => f.name ? f.name : f.toString();\n\n/**\n * inspectArray :: [a] -> string\n *\n * inspectArray maps over input array [a] and outputs string representing it.\n */\nexport const inspectArray = a => `[${a.map(deepInspect).join(', ')}]`;\n\n/**\n * inspectString :: a -> string\n *\n * inspectString outputs string representing input.\n */\nexport const inspectString = a => `'${a}'`;\n\n/**\n * inspectObject :: a -> string\n *\n * inspectObject outputs string representing input.\n */\nexport const inspectObject = a =>\n  isFunction(a.inspect)\n    ? a.inspect()\n    : `{${Object.keys(a).map(k => [k, deepInspect(a[k])]).map(kv => kv.join(': ')).join(', ')}}`;\n\n/**\n * deepInspect :: a -> string\n *\n * deepInspect runs recursively over input and outputs string representing the input.\n */\nexport const deepInspect = a =>\n  isFunction(a)\n    ? inspectFunction(a)\n    : isArray(a)\n      ? inspectArray(a)\n      : isObject(a)\n        ? inspectObject(a)\n        : isString(a)\n          ? inspectString(a)\n          : String(a);","/**\n * trim :: string -> string\n *\n * trim output is a string without white characters around it.\n */\nexport const trim = a => a.trim();\n\n/**\n * includes :: string -> string -> boolean\n *\n * includes output is true if b includes a.\n */\nexport const includes = a => b => b.includes(a);\n\n/**\n * testRegEx :: regex -> string -> boolean\n *\n * testRegEx returns true if string b passes regular expression a.\n */\nexport const testRegEx = a => b => a.test(b);","import {deepInspect} from \"./utils\";\nimport {isNothing} from \"./conditional\";\nimport {identity} from \"./core\";\n\n/**\n * Maybe.of() outputs instance of Maybe.\n * Maybe.of(a).inspect() outputs string Just(a) or Nothing.\n * Maybe.of(a) outputs Nothing for an input that is null, undefined, an empty string or an empty array.\n * Maybe.of(a) outputs Just for an input a that is not Nothing.\n * Maybe.of(a) outputs Nothing for an input a that is null or undefined.\n * Maybe.of(a).isJust() of an input a outputs true for a value that is Just.\n * Maybe.of(a).isNothing() of an input a outputs true for a value that is Nothing.\n * Maybe.of(a).map(a -> b) executes function over Maybe input a.\n * Maybe.of(a).map(a -> Just) outputs Just(Just).\n * Maybe.of(a).map(a -> b) does not execute over Nothing.\n * Maybe.of(a).flatMap(a -> b) executes function over Maybe input a returns its raw value.\n * Maybe.of(a).flatMap(a -> b) does not execute over Nothing.\n * Maybe.of(a).map(a -> b).ap(Maybe) provides applicative ability to apply functors to each other.\n * Maybe.of(Maybe -> Maybe -> c).ap(Maybe).ap(Maybe) provides applicative interface for a functor of a function.\n */\nexport class Maybe {\n  constructor(x) {\n    this.value = x;\n  }\n\n  static of(x) {\n    return isNothing(x) ? new Nothing(x) : new Just(x) ;\n  }\n}\n\nclass Just extends Maybe {\n  inspect() {\n    return `Just(${deepInspect(this.value)})`;\n  }\n\n  isNothing() {\n    return false;\n  }\n\n  isJust() {\n    return true;\n  }\n\n  map(fn) {\n    return Maybe.of(fn(this.value));\n  }\n\n  flatMap(fn) {\n    return fn(this.value);\n  }\n\n  ap(f) {\n    return f.map(this.value);\n  }\n\n  sequence(of) {\n    this.traverse(of, identity);\n  }\n\n  traverse(of, fn) {\n    return fn(this.value).map(Maybe.of);\n  }\n}\n\nclass Nothing extends Maybe {\n  inspect () {\n    return 'Nothing';\n  }\n\n  isNothing() {\n    return true\n  }\n\n  isJust() {\n    return false;\n  }\n\n  map(fn) {\n    return this;\n  }\n\n  flatMap(fn) {\n    return this;\n  }\n\n  ap(f) {\n    return this;\n  }\n\n  sequence(of) {\n    return of(this);\n  }\n\n  traverse(of, fn) {\n    return of(this);\n  }\n}","import {deepInspect} from \"./utils\";\nimport {identity} from \"./core\";\n\n/**\n * Either.of() outputs instance of Either.\n * Either.of(a) outputs instance of Right holding its input value.\n * Either.Right(a) outputs instance of Right holding its input value.\n * Either.Left(a) outputs instance of Left holding its input value.\n * Either.of(a).inspect() outputs string Right(a).\n * Either.Right(a).inspect() outputs string Right(a).\n * Either.Left(a).inspect() outputs string Left(a).\n * Either.of(a).isRight() always outputs true.\n * Either.Left(a).isLeft() outputs false if Either is Left.\n * Either.try(a -> b) outputs Right(b) if no error is thrown.\n * Either.try(a -> b) outputs Left(e.message) if error is thrown.\n * Either.of(a).map(a -> b) executes function over Either input a.\n * Either.of(a).map(a -> Right) outputs Right(Right).\n * Either.Left(a).map(a -> b) does not execute provided function and retains Left input value.\n * Either.of(a).flatMap(a -> b) executes function over Either input a returns its raw value through flatten.\n * Either.Left(a).flatMap(a -> b) does not execute provided function and retains Left input value.\n * Either.of(Either -> Either -> c).ap(Either).ap(Either) provides applicative interface.\n */\nexport class Either {\n  constructor(x) {\n    this.value = x;\n  }\n\n  static of(x) {\n    return new Right(x);\n  }\n\n  static Right(x) {\n    return new Right(x);\n  }\n\n  static Left(x) {\n    return new Left(x);\n  }\n\n  static try(fn) {\n    try {\n      return new Right(fn());\n    } catch(e) {\n      return new Left(e.message);\n    }\n  }\n}\n\nclass Right extends Either {\n  inspect() {\n    return `Right(${deepInspect(this.value)})`;\n  }\n\n  isLeft() {\n    return false;\n  }\n\n  isRight() {\n    return true;\n  }\n\n  map(fn) {\n    return Either.of(fn(this.value));\n  }\n\n  flatMap(fn) {\n    return fn(this.value);\n  }\n\n  ap(f) {\n    return f.map(this.value);\n  }\n\n  sequence(of) {\n    return this.traverse(of, identity);\n  }\n\n  traverse(of, fn) {\n    fn(this.value).map(Either.of);\n  }\n}\n\nclass Left extends Either {\n  inspect() {\n    return `Left(${deepInspect(this.value)})`;\n  }\n\n  isLeft() {\n    return true;\n  }\n\n  isRight() {\n    return false;\n  }\n\n  map() {\n    return this;\n  }\n\n  flatMap() {\n    return this;\n  }\n\n  ap() {\n    return this;\n  }\n\n  sequence(of) {\n    return of(this);\n  }\n\n  traverse(of, fn) {\n    return of(this);\n  }\n}","import {compose} from \"./core\";\nimport {deepInspect} from \"./utils\";\n\n/**\n * syncEffect.of() outputs instance of syncEffect.\n * syncEffect.of(() -> a).inspect() outputs string syncEffect(a).\n * syncEffect.of(() -> a).trigger() executes function provided as input of syncEffect.\n * syncEffect.of(() -> a).map(b -> c) composes function over syncEffect input function.\n * syncEffect.of(() -> a).map(b -> syncEffect) outputs syncEffect(syncEffect).\n * syncEffect.of(() -> a).flatMap(b -> syncEffect) outputs syncEffect.\n * syncEffect.of(() -> a).map(a -> b).ap(syncEffect) provides applicative ability to apply functors to each other.\n * syncEffect.of(syncEffect -> syncEffect -> c).ap(syncEffect).ap(syncEffect) provides applicative interface for a functor of a function.\n * No input function is executed until trigger is called.\n */\nexport class syncEffect {\n  constructor(fn) {\n    this.trigger = fn;\n  }\n\n  inspect() {\n    return `syncEffect(${deepInspect(this.trigger)})`;\n  }\n\n  static of(x) {\n    return new syncEffect(x);\n  }\n\n  map(fn) {\n    return new syncEffect(compose(fn, this.trigger));\n  }\n\n  flatMap(fn) {\n    return new syncEffect(() => {\n      return this.map(fn).trigger().trigger();\n    })\n  }\n\n  ap(f) {\n    return this.flatMap(fn => f.map(fn));\n  }\n}","export * from './list';\nexport * from './core';\nexport * from './utils';\nexport * from './conditional';\nexport * from './string';\nexport * from './maybe';\nexport * from './either';\nexport * from './syncEffect';"],"sourceRoot":""}