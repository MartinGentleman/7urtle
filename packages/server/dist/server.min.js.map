{"version":3,"sources":["webpack://server/webpack/universalModuleDefinition","webpack://server/webpack/bootstrap","webpack://server/external \"fs\"","webpack://server/./node_modules/@babel/runtime/helpers/defineProperty.js","webpack://server/external \"http\"","webpack://server/./node_modules/mime-types/index.js","webpack://server/./node_modules/mime-db/index.js","webpack://server/external \"path\"","webpack://server/./node_modules/@7urtle/lambda/src/conditional.js","webpack://server/./node_modules/@7urtle/lambda/src/utils.js","webpack://server/./node_modules/@7urtle/lambda/src/list.js","webpack://server/./node_modules/@7urtle/lambda/src/string.js","webpack://server/./node_modules/@7urtle/lambda/src/Maybe.js","webpack://server/./node_modules/@7urtle/lambda/src/Either.js","webpack://server/./node_modules/@7urtle/lambda/src/SyncEffect.js","webpack://server/./src/Router.js","webpack://server/./src/ResponseEffect.js","webpack://server/./src/Server.js","webpack://server/./src/apis/api404.js","webpack://server/./src/apis/apiFile.js","webpack://server/./src/index.js"],"names":["root","factory","exports","module","define","amd","this","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","require","obj","configurable","writable","extensions","types","preference","db","extname","EXTRACT_TYPE_REGEXP","TEXT_TYPE_REGEXP","charset","type","match","exec","mime","toLowerCase","test","charsets","lookup","contentType","str","indexOf","extension","exts","length","path","substr","undefined","keys","forEach","from","source","to","isEqual","a","b","isTypeOf","typeOf","isString","isNull","isUndefined","isObject","isArray","Array","isFunction","isLength","lengthOf","isEmpty","isNothing","isNotLength","isNotEqual","isJust","passThrough","f","deepInspect","console","log","String","inspectFunction","join","map","inspectArray","inspect","k","keysOf","inspectObject","inspectString","mapper","list","separator","lowerCaseOf","entries","string","Maybe_Maybe","[object Object]","x","Nothing","Maybe_Just","fn","of","Either","Either_Right","Either_Left","e","message","SyncEffect_SyncEffect","trigger","flatMap","findRoute","configuration","request","error","onJust","functorMaybe","maybe","Left","Right","Maybe","routes","find","route","substring","endsWith","startsWith","limit","start","getApiResultForError","any","emptyContent","resultEither","result","_objectSpread","contentLength","Buffer","byteLength","content","file","Router","isLeft","catchApiError","tried","catchApiException","api","method","getApiResult","sendHead","response","responseHook","writeHead","status","content-type","content-length","getHeaders","sendOrStream","fs","existsSync","createReadStream","pipe","streamFile","end","sendContent","ResponseEffect","SyncEffect","getResponse","requestHook","url","getRequest","requestListener","Server","on","onRequest","http","createServer","listen","port","api404","apiFile","fileExists","mimeTypes","statSync","size","defaultConfiguration","process","env","404","__webpack_exports__","src_objectSpread"],"mappings":"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","file":"server.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"server\"] = factory();\n\telse\n\t\troot[\"server\"] = factory();\n})(this, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 7);\n","module.exports = require(\"fs\");","function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nmodule.exports = _defineProperty;","module.exports = require(\"http\");","/*!\n * mime-types\n * Copyright(c) 2014 Jonathan Ong\n * Copyright(c) 2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict'\n\n/**\n * Module dependencies.\n * @private\n */\n\nvar db = require('mime-db')\nvar extname = require('path').extname\n\n/**\n * Module variables.\n * @private\n */\n\nvar EXTRACT_TYPE_REGEXP = /^\\s*([^;\\s]*)(?:;|\\s|$)/\nvar TEXT_TYPE_REGEXP = /^text\\//i\n\n/**\n * Module exports.\n * @public\n */\n\nexports.charset = charset\nexports.charsets = { lookup: charset }\nexports.contentType = contentType\nexports.extension = extension\nexports.extensions = Object.create(null)\nexports.lookup = lookup\nexports.types = Object.create(null)\n\n// Populate the extensions/types maps\npopulateMaps(exports.extensions, exports.types)\n\n/**\n * Get the default charset for a MIME type.\n *\n * @param {string} type\n * @return {boolean|string}\n */\n\nfunction charset (type) {\n  if (!type || typeof type !== 'string') {\n    return false\n  }\n\n  // TODO: use media-typer\n  var match = EXTRACT_TYPE_REGEXP.exec(type)\n  var mime = match && db[match[1].toLowerCase()]\n\n  if (mime && mime.charset) {\n    return mime.charset\n  }\n\n  // default text/* to utf-8\n  if (match && TEXT_TYPE_REGEXP.test(match[1])) {\n    return 'UTF-8'\n  }\n\n  return false\n}\n\n/**\n * Create a full Content-Type header given a MIME type or extension.\n *\n * @param {string} str\n * @return {boolean|string}\n */\n\nfunction contentType (str) {\n  // TODO: should this even be in this module?\n  if (!str || typeof str !== 'string') {\n    return false\n  }\n\n  var mime = str.indexOf('/') === -1\n    ? exports.lookup(str)\n    : str\n\n  if (!mime) {\n    return false\n  }\n\n  // TODO: use content-type or other module\n  if (mime.indexOf('charset') === -1) {\n    var charset = exports.charset(mime)\n    if (charset) mime += '; charset=' + charset.toLowerCase()\n  }\n\n  return mime\n}\n\n/**\n * Get the default extension for a MIME type.\n *\n * @param {string} type\n * @return {boolean|string}\n */\n\nfunction extension (type) {\n  if (!type || typeof type !== 'string') {\n    return false\n  }\n\n  // TODO: use media-typer\n  var match = EXTRACT_TYPE_REGEXP.exec(type)\n\n  // get extensions\n  var exts = match && exports.extensions[match[1].toLowerCase()]\n\n  if (!exts || !exts.length) {\n    return false\n  }\n\n  return exts[0]\n}\n\n/**\n * Lookup the MIME type for a file path/extension.\n *\n * @param {string} path\n * @return {boolean|string}\n */\n\nfunction lookup (path) {\n  if (!path || typeof path !== 'string') {\n    return false\n  }\n\n  // get the extension (\"ext\" or \".ext\" or full path)\n  var extension = extname('x.' + path)\n    .toLowerCase()\n    .substr(1)\n\n  if (!extension) {\n    return false\n  }\n\n  return exports.types[extension] || false\n}\n\n/**\n * Populate the extensions and types maps.\n * @private\n */\n\nfunction populateMaps (extensions, types) {\n  // source preference (least -> most)\n  var preference = ['nginx', 'apache', undefined, 'iana']\n\n  Object.keys(db).forEach(function forEachMimeType (type) {\n    var mime = db[type]\n    var exts = mime.extensions\n\n    if (!exts || !exts.length) {\n      return\n    }\n\n    // mime -> extensions\n    extensions[type] = exts\n\n    // extension -> mime\n    for (var i = 0; i < exts.length; i++) {\n      var extension = exts[i]\n\n      if (types[extension]) {\n        var from = preference.indexOf(db[types[extension]].source)\n        var to = preference.indexOf(mime.source)\n\n        if (types[extension] !== 'application/octet-stream' &&\n          (from > to || (from === to && types[extension].substr(0, 12) === 'application/'))) {\n          // skip the remapping\n          continue\n        }\n      }\n\n      // set the extension -> mime\n      types[extension] = type\n    }\n  })\n}\n","/*!\n * mime-db\n * Copyright(c) 2014 Jonathan Ong\n * MIT Licensed\n */\n\n/**\n * Module exports.\n */\n\nmodule.exports = require('./db.json')\n","module.exports = require(\"path\");","import {typeOf, lengthOf} from \"./utils\";\n\n/**\n * isEqual :: a -> b -> boolean\n *\n * isEqual output is true if strict equality between a and b is true.\n * isEqual output is always false for comparison of objects and arrays.\n */\nexport const isEqual = a => b => a === b;\n\n/**\n * isNotEqual :: a -> b -> boolean\n *\n * isNotEqual output is true if strict equality between a and b is false.\n * isNotEqual output is always true for comparison of objects and arrays.\n */\nexport const isNotEqual = a => b => a !== b;\n\n/**\n * isTrue :: a -> boolean\n *\n * isTrue output is true if input is true.\n */\nexport const isTrue = isEqual(true);\n\n/**\n * isFalse :: a -> Boolean\n *\n * isFalse output is true if input is false.\n */\nexport const isFalse = isEqual(false);\n\n/**\n * isGreaterThan :: a -> b -> boolean\n *\n * isGreaterThan output is true if b is greater than a.\n */\nexport const isGreaterThan = a => b => b > a;\n\n/**\n * isLessThan :: a -> b -> boolean\n *\n * isLessThan output is true if b is less than a.\n */\nexport const isLessThan = a => b => b < a;\n\n/**\n * isAtLeast :: a -> b -> boolean\n *\n * isAtLeast output is true if b is greater or equal to a.\n */\nexport const isAtLeast = a => b => b >= a;\n\n/**\n * isAtMost :: a -> b -> boolean\n *\n * isAtMost output is true if b is less or equal to a.\n */\nexport const isAtMost = a => b => b <= a;\n\n/**\n * isTypeOf :: a -> b -> boolean\n *\n * isTypeOf output is true if b is a type of a.\n */\nexport const isTypeOf = a => b => isEqual(typeOf(b))(a);\n\n/**\n * isString :: a -> boolean\n *\n * isString output is true if b is a string.\n */\nexport const isString = isTypeOf('string');\n\n/**\n * isBoolean :: a -> boolean\n *\n * isBoolean output is true if b is a boolean.\n */\nexport const isBoolean = isTypeOf('boolean');\n\n/**\n * isNull :: a -> boolean\n *\n * isNull output is true if b is a null.\n */\nexport const isNull = isEqual(null);\n\n/**\n * isUndefined :: a -> boolean\n *\n * isUndefined output is true if b is an undefined.\n */\nexport const isUndefined = isTypeOf('undefined');\n\n/**\n * isNumber :: a -> boolean\n *\n * isNumber output is true if b is a number.\n */\nexport const isNumber = isTypeOf('number');\n\n/**\n * isObject :: a -> boolean\n *\n * isObject output is true if b is an object, array of null.\n */\nexport const isObject = isTypeOf('object');\n\n/**\n * isArray :: a -> boolean\n *\n * isArray output is true if b is an array.\n */\nexport const isArray = Array.isArray;\n\n/**\n * isFunction :: a -> boolean\n *\n * isFunction output is true if b is a function.\n */\nexport const isFunction = isTypeOf('function');\n\n/**\n * isLength :: (string|array) -> b -> boolean\n *\n * isLength output is true if b is a length of a.\n */\nexport const isLength = a => b => isEqual(lengthOf(b))(a);\n\n/**\n * isNotLength :: (string|array) -> b -> boolean\n *\n * isNotLength output is true if b is not a length of a.\n */\nexport const isNotLength = a => b => !isLength(a)(b);\n\n/**\n * isEmpty :: (string|array) -> boolean\n *\n * isEmpty output is true if input has a length of 0.\n * isEmpty output is always false if input is an object and not an array or a string.\n */\nexport const isEmpty = isLength(0);\n\n/**\n * isNotEmpty :: (string|array) -> boolean\n *\n * isNotEmpty output is true if input does not have a length of 0.\n * isNotEmpty output is always true if input is an object and not an array or a string.\n */\nexport const isNotEmpty = isNotLength(0);\n\n/**\n * isZero :: a -> boolean\n *\n * isZero output is true if a is 0.\n */\nexport const isZero = isEqual(0);\n\n/**\n * isNotZero :: a -> boolean\n *\n * isNotZero output is true if a is not 0.\n */\nexport const isNotZero = isNotEqual(0);\n\n/**\n * isNothing :: a -> boolean\n *\n * isNothing returns true if input is null, undefined or empty string or empty array.\n */\nexport const isNothing = a => isNull(a) || isUndefined(a) || isEmpty(a);\n\n/**\n * isJust :: a -> boolean\n *\n * isJust returns true if input is not null, undefined or empty string or empty array.\n */\nexport const isJust = a => !isNothing(a);","import {isArray, isEqual, isString, isObject, isFunction, isNull, isUndefined} from \"./conditional\";\nimport {keysOf, join, map} from \"./list\";\n\n/**\n * typeOf :: a -> string\n *\n * typeOf outputs type of its input a.\n */\nexport const typeOf = a => typeof a;\n\n/**\n * lengthOf :: (string|array) -> number\n */\nexport const lengthOf = a => a.length;\n\n/**\n * passThrough :: function -> a -> a\n *\n * passThrough output is the same as input a.\n * passThrough executes function passed as first argument.\n */\nexport const passThrough = f => a => {\n  f(a);\n  return a;\n};\n\n/**\n * log :: a -> a\n *\n * log output is the same as input.\n * log causes side effect of console.log.\n */\nexport const log = passThrough(console.log);\n\n/**\n * spy :: a -> a\n *\n * spy output is the same as input.\n * spy causes side effect of console.log.\n */\nexport const spy = passThrough(a => console.log(deepInspect(a)));\n\n/**\n * minusOneToUndefined :: a -> a|boolean\n *\n * minusOneToUndefined output is the same as input or undefined if input is -1.\n */\nexport const minusOneToUndefined = a => isEqual(-1)(a) ? undefined: a;\n\n/**\n * inspectFunction :: (a -> b) -> string\n *\n * inspectFunction outputs name of named function or its conversion to string.\n */\nexport const inspectFunction = f => f.name ? f.name : String(f);\n\n/**\n * inspectArray :: [a] -> string\n *\n * inspectArray maps over input array [a] and outputs string representing it.\n */\nexport const inspectArray = a => `[${join(', ')(map(deepInspect)(a))}]`;\n\n/**\n * inspectString :: a -> string\n *\n * inspectString outputs string representing input.\n */\nexport const inspectString = a => `'${a}'`;\n\n/**\n * inspectObject :: a -> string\n *\n * inspectObject outputs string representing input.\n */\nexport const inspectObject = a =>\n  isFunction(a.inspect)\n    ? a.inspect()\n    : `{${join(', ')(map(join(': '))(map(k => [k, deepInspect(a[k])])(keysOf(a))))}}`\n\n/**\n * deepInspect :: a -> string\n *\n * deepInspect runs recursively over input and outputs string representing the input.\n */\nexport const deepInspect = a =>\n  isUndefined(a)\n    ? 'undefined'\n    : isNull(a)\n      ? 'null'\n      : isFunction(a)\n        ? inspectFunction(a)\n        : isArray(a)\n          ? inspectArray(a)\n          : isObject(a)\n            ? inspectObject(a)\n            : isString(a)\n              ? inspectString(a)\n              : String(a);","import {minusOneToUndefined} from './utils';\n\n/**\n * reduce :: a -> ((a, b) -> a) -> [b] -> a\n *\n * reduce executes input reducer function that over each member of input array [b] to output single value a.\n *\n * reduce executes functions in reverse order to reduceRight.\n */\nexport const reduce = initial => reducer => list => list.reduce(reducer, initial);\n\n/**\n * reduceRight :: a -> ((a, b) -> a) -> [b] -> a\n *\n * reduceRight executes input reducer function that over each member of input array [b] to output single value a.\n *\n * reduceRight executes functions in reverse order to reduce.\n */\nexport const reduceRight = initial => reducer => list => list.reduceRight(reducer, initial);\n\n/**\n * map :: (a -> b) -> [a] -> [b]\n *\n * map executes input mapper over each member of input array [a] to output new array [b].\n */\nexport const map = mapper => list => list.map(mapper);\n\n/**\n * filter :: (a -> boolean) -> [a] -> [b]\n *\n * filter executes input checker over each member of input array [a] to filter and output filtered new array [b].\n */\nexport const filter = checker => list => list.filter(checker);\n\n/**\n * find :: (a -> boolean) -> [a] -> [b]\n *\n * find executes input checker over each member of input array [a] and outputs the first array member that matches checker or undefined.\n */\nexport const find = checker => list => list.find(checker);\n\n/**\n * findIndex :: (a -> boolean) -> [a] -> [b]\n *\n * findIndex executes input checker over each member of input array [a] and outputs the index of first array member that matches checker or undefined.\n */\nexport const findIndex = checker => list => minusOneToUndefined(list.findIndex(checker));\n\n/**\n * join :: string -> [a] -> string\n *\n * join outputs a string created by joining input array members with input separator.\n */\nexport const join = separator => list => list.join(separator);\n\n/**\n * keysOf :: object -> [string]\n *\n * keysOf outputs array of string keys of input array or object.\n */\nexport const keysOf = Object.keys;\n\n/**\n * entriesOf :: object -> [[string, a]]\n *\n * entriesOf outputs array of arrays of string keys and raw values of input array or object.\n */\nexport const entriesOf = Object.entries;\n\n/**\n * everyOf :: (a -> boolean) -> [a] -> boolean\n *\n * everyOf outputs true if every element of input array passes input checker function as true.\n */\nexport const everyOf = checker => list => list.every(checker);\n\n/**\n * slice :: number -> number -> [a] -> [a]\n *\n * slice outputs selected array elements as an array based on input range.\n */\nexport const slice = end => start => list => list.slice(start, end);\n\n/**\n * some :: (a -> boolean) -> [a] -> boolean\n *\n * some outputs true if any element of input array passes input checker function as true.\n */\nexport const someOf = checker => list => list.some(checker);","import {minusOneToUndefined} from './utils';\n\n/**\n * trim :: string -> string\n *\n * trim output is a string without white characters around it.\n */\nexport const trim = string => string.trim();\n\n/**\n * testRegEx :: regex -> string -> boolean\n *\n * testRegEx outputs true if string b passes regular expression a.\n */\nexport const testRegEx = regex => string => regex.test(string);\n\n/**\n * substr :: number -> number -> string -> string\n * \n * substr outputs substring based on provided string, start and limit.\n */\nexport const substr = limit => start => string => string.substr(start, limit);\n\n/**\n * startsWith :: string -> string -> boolean\n * \n * startsWith outputs true if an input string starts with provided string.\n */\nexport const startsWith = substring => string => string.startsWith(substring);\n\n/**\n * endsWith :: string -> string -> boolean\n * \n * endsWith outputs true if an input string ends with provided string.\n */\nexport const endsWith = substring => string => string.endsWith(substring);\n\n/**\n * repeat :: number -> string -> string\n * \n * repeat outputs new string repeating input string inputed count of times.\n */\nexport const repeat = count => string => string.repeat(count);\n\n/**\n * replace :: string -> string -> string -> string\n * \n * replace outputs new string replacing input substring with input replacement string in input string.\n */\nexport const replace = replacement => substring => string => string.replace(substring, replacement);\n\n/**\n * search :: string/regex -> string -> number\n * \n * search outputs position of input substring or regular expression withing input string or undefined if it is not found.\n */\nexport const search = substring => string => minusOneToUndefined(string.search(substring));\n\n/**\n * split :: string -> string -> array\n * \n * split outputs and array of an input string split by the input substring.\n */\nexport const split = substring => string => string.split(substring);\n\n/**\n * lowerCaseOf :: string -> string\n * \n * lowerCaseOf ouputs the lower case version of input string.\n */\nexport const lowerCaseOf = string => string.toLowerCase();\n\n/**\n * upperCaseOf :: string -> string\n * \n * upperCaseOf ouputs the upper case version of input string.\n */\nexport const upperCaseOf = string => string.toUpperCase();","import {deepInspect} from \"./utils\";\nimport {isNothing} from \"./conditional\";\n\n/**\n * Maybe.of() outputs instance of Maybe.\n * Maybe.of(a).inspect() outputs string Just(a) or Nothing.\n * Maybe.of(a) outputs Nothing for an input that is null, undefined, an empty string or an empty array.\n * Maybe.of(a) outputs Just for an input a that is not Nothing.\n * Maybe.of(a) outputs Nothing for an input a that is null or undefined.\n * Maybe.of(a).isJust() of an input a outputs true for a value that is Just.\n * Maybe.of(a).isNothing() of an input a outputs true for a value that is Nothing.\n * Maybe.of(a).map(a -> b) executes function over Maybe input a.\n * Maybe.of(a).map(a -> Just) outputs Just(Just).\n * Maybe.of(a).map(a -> b) does not execute over Nothing.\n * Maybe.of(a).flatMap(a -> b) executes function over Maybe input a returns its raw value.\n * Maybe.of(a).flatMap(a -> b) does not execute over Nothing.\n * Maybe.of(a).map(a -> b).ap(Maybe) provides applicative ability to apply functors to each other.\n * Maybe.of(Maybe -> Maybe -> c).ap(Maybe).ap(Maybe) provides applicative interface for a functor of a function.\n */\nexport class Maybe {\n  constructor(x) {\n    this.value = x;\n  }\n\n  static of(x) {\n    return isNothing(x) ? new Nothing(x) : new Just(x) ;\n  }\n}\n\nclass Just extends Maybe {\n  inspect() {\n    return `Just(${deepInspect(this.value)})`;\n  }\n\n  isNothing() {\n    return false;\n  }\n\n  isJust() {\n    return true;\n  }\n\n  map(fn) {\n    return Maybe.of(fn(this.value));\n  }\n\n  flatMap(fn) {\n    return fn(this.value);\n  }\n\n  ap(f) {\n    return f.map(this.value);\n  }\n}\n\nclass Nothing extends Maybe {\n  inspect () {\n    return 'Nothing';\n  }\n\n  isNothing() {\n    return true\n  }\n\n  isJust() {\n    return false;\n  }\n\n  map(fn) {\n    return this;\n  }\n\n  flatMap(fn) {\n    return this;\n  }\n\n  ap(f) {\n    return this;\n  }\n}\n\n/**\n * maybe :: a -> (b -> c) -> Maybe\n *\n * maybe outputs result of a function onJust if input Maybe is Just or outputs input error if input Maybe is Nothing.\n */\nexport const maybe = error => onJust => functorMaybe =>\n  functorMaybe.isNothing()\n    ? error\n    : onJust(functorMaybe.value);","import {deepInspect} from \"./utils\";\n\n/**\n * Either.of() outputs instance of Either.\n * Either.of(a) outputs instance of Right holding its input value.\n * Either.Right(a) outputs instance of Right holding its input value.\n * Either.Left(a) outputs instance of Left holding its input value.\n * Either.of(a).inspect() outputs string Right(a).\n * Either.Right(a).inspect() outputs string Right(a).\n * Either.Left(a).inspect() outputs string Left(a).\n * Either.of(a).isRight() always outputs true.\n * Either.Left(a).isLeft() outputs false if Either is Left.\n * Either.try(a -> b) outputs Right(b) if no error is thrown.\n * Either.try(a -> b) outputs Left(e.message) if error is thrown.\n * Either.of(a).map(a -> b) executes function over Either input a.\n * Either.of(a).map(a -> Right) outputs Right(Right).\n * Either.Left(a).map(a -> b) does not execute provided function and retains Left input value.\n * Either.of(a).flatMap(a -> b) executes function over Either input a returns its raw value through flatten.\n * Either.Left(a).flatMap(a -> b) does not execute provided function and retains Left input value.\n * Either.of(Either -> Either -> c).ap(Either).ap(Either) provides applicative interface.\n */\nexport class Either {\n  constructor(x) {\n    this.value = x;\n  }\n\n  static of(x) {\n    return new Right(x);\n  }\n\n  static Right(x) {\n    return new Right(x);\n  }\n\n  static Left(x) {\n    return new Left(x);\n  }\n\n  static try(fn) {\n    try {\n      return new Right(fn());\n    } catch(e) {\n      return new Left(e.message);\n    }\n  }\n}\n\nclass Right extends Either {\n  inspect() {\n    return `Right(${deepInspect(this.value)})`;\n  }\n\n  isLeft() {\n    return false;\n  }\n\n  isRight() {\n    return true;\n  }\n\n  map(fn) {\n    return Either.of(fn(this.value));\n  }\n\n  flatMap(fn) {\n    return fn(this.value);\n  }\n\n  ap(f) {\n    return f.map(this.value);\n  }\n}\n\nclass Left extends Either {\n  inspect() {\n    return `Left(${deepInspect(this.value)})`;\n  }\n\n  isLeft() {\n    return true;\n  }\n\n  isRight() {\n    return false;\n  }\n\n  map() {\n    return this;\n  }\n\n  flatMap() {\n    return this;\n  }\n\n  ap() {\n    return this;\n  }\n}\n\n/**\n * either :: (a -> b) -> (b -> c) -> Either\n *\n * either outputs result of a function onRight if input Either is Right or outputs result of a function onLeft if input Either is Left.\n */\nexport const either = onLeft => onRight => functorEither =>\n  functorEither.isLeft()\n    ? onLeft(functorEither.value)\n    : onRight(functorEither.value);","import {deepInspect} from \"./utils\";\n\n/**\n * SyncEffect.of() outputs instance of SyncEffect.\n * SyncEffect.wrap(a) is equal to SyncEffect.of(() -> a).\n * SyncEffect.of(() -> a).inspect() outputs string SyncEffect(a).\n * SyncEffect.of(() -> a).trigger() executes function provided as input of SyncEffect.\n * SyncEffect.of(() -> a).map(b -> c) composes function over SyncEffect input function.\n * SyncEffect.of(() -> a).map(b -> SyncEffect) outputs SyncEffect(SyncEffect).\n * SyncEffect.of(() -> a).flatMap(b -> SyncEffect) outputs SyncEffect.\n * SyncEffect.of(() -> a).map(a -> b).ap(SyncEffect) provides applicative ability to apply functors to each other.\n * SyncEffect.of(SyncEffect -> SyncEffect -> c).ap(SyncEffect).ap(SyncEffect) provides applicative interface for a functor of a function.\n * No input function is executed until trigger is called.\n */\nexport class SyncEffect {\n  constructor(fn) {\n    this.trigger = fn;\n  }\n\n  inspect() {\n    return `SyncEffect(${deepInspect(this.trigger)})`;\n  }\n\n  static of(x) {\n    return new SyncEffect(x);\n  }\n\n  static wrap(x) {\n    return new SyncEffect(() => x);\n  }\n\n  map(fn) {\n    return new SyncEffect(a => fn(this.trigger(a)));\n  }\n\n  flatMap(fn) {\n    return new SyncEffect(() => {\n      return this.map(fn).trigger().trigger();\n    })\n  }\n\n  ap(f) {\n    return this.flatMap(fn => f.map(fn));\n  }\n}","import {isEqual, isFunction, isUndefined, maybe, Maybe, Either, endsWith, startsWith, substr, lengthOf} from \"@7urtle/lambda\";\n\n/**\n * checkRoute :: string -> object -> boolean\n *\n * checkRoute outputs true if inputs path and route.path match.\n * checkRoute supports /* routes.\n */\nconst checkRoute = path => route =>\n  endsWith('/*')(route.path)\n    ? startsWith(substr(lengthOf(route.path) -2)(0)(route.path))(path)\n    : isEqual(route.path)(path);\n\n/**\n * findRoute :: object -> object -> (object|undefined)\n *\n * findRoute outputs route object found in input configuration.routes based on input request.path or undefined if no path matches.\n */\nconst findRoute = configuration => request =>\n  maybe(Either.Left(404))\n       (Either.Right)\n       (Maybe.of(configuration.routes.find(checkRoute(request.path))));\n\n/**\n * getApiResultForError :: object -> object -> Either -> Either\n *\n * getApiResultForError outputs Either of error api call result for the error status defaulting to general error api.\n */\nconst getApiResultForError = configuration => request => error =>\n  !isUndefined(configuration[error.value]) && isFunction(configuration[error.value].any) // is there an api for the error?\n    ? configuration[error.value].any(request) // call api for the error\n    : configuration.error.any(request); // call api for general error\n\n/**\n * catchApiException :: object -> object -> Either -> Either\n *\n * catchApiException outputs the same Either or Either of 500 error call if input Either caught an exception.\n */\nconst catchApiException = configuration => request => tried =>\n  tried.isLeft() ? Either.Right(configuration.error.any(request)) : tried;\n\n/**\n * emptyContent :: Either -> Either\n *\n * emptyContent outputs Either of result with empty file and content based on input Either.\n */\nconst emptyContent = resultEither => resultEither.map(result => ({\n  ...result,\n  contentLength: result.contentLength || Buffer.byteLength(result.content),\n  file: '',\n  content: ''\n}));\n\n/**\n * getApiResult :: object -> object -> Either -> Either\n *\n * getApiResult outputs Either of api call result.\n * getApiResult if head is not api call it outputs Either of api call for get or any with empty file and content result or 404 result if neither are found.\n * getApiResult outputs Either of api 404 error call if route is not found.\n * getApiResult outputs Either of api any call if requested method call is not found.\n * getApiResult outputs Either of 404 api call if both requested method call and any call are not found.\n * getApiResult outputs Left of error code if api call returns Left.\n */\nconst getApiResult = configuration => request => route =>\n  route.isLeft() // was route not found?\n    ? getApiResultForError(configuration)(request)(route) // get api result for error\n    : isFunction(route.value.api[request.method]) // is there api call for the request method?\n      ? route.value.api[request.method](request) // call api for the request method\n      : isEqual(request.method)('head') // is request method HEAD?\n        ? isFunction(route.value.api.get) // can I use get instead of head\n          ? emptyContent(route.value.api.get(request)) // use get instead of head\n          : isFunction(route.value.api.any) // can I used any instead of head\n            ? emptyContent(route.value.api.any(request)) // use any instead of head\n            : emptyContent(configuration[404].any(request)) // call api for 404 error\n        : isFunction(route.value.api.any) // is there api any function?\n          ? route.value.api.any(request) // call api any function\n          : configuration[404].any(request); // call api for 404 error\n\n/**\n * catchApiError :: object -> object -> Either -> Either\n *\n * catchApiError outputs Either of error api call result for the error status or original input result.\n */\nconst catchApiError = configuration => request => result =>\n  result.isLeft()\n    ? getApiResultForError(configuration)(request)(result)\n    : result;\n\n/**\n * getResponse :: object -> object -> object\n *\n * getResponse outputs response object.\n * getResponse outputs response object for 404 api call if route is not found.\n * getResponse outputs response object for error api call if api call returns an error.\n * getResponse outputs response object for error api call if api call throws an exception.\n */\nconst getResponse = configuration => request =>\n  catchApiError(configuration)(request)( // we convert left api call result into error api call result\n    catchApiException(configuration)(request)( // we convert thrown exception into 500 error api call result\n      Either.try( // we use Either.try to catch thrown exceptions\n        () => getApiResult(configuration)(request)( // we call api associated with the found route\n          findRoute(configuration)(request) // first we find the right route or left 404\n        )\n      )\n    ).value\n  ).value;\n\nexport default {getResponse};\n\nexport {\n  checkRoute,\n  findRoute,\n  getApiResultForError,\n  catchApiException,\n  emptyContent,\n  getApiResult,\n  catchApiError\n};","import {SyncEffect, Either, passThrough, isJust} from \"@7urtle/lambda\";\nimport fs from \"fs\";\n\n/**\n * getHeaders :: object -> object\n *\n * getHeaders creates headers object out of response object.\n * getHeaders uses text/plain content type if content-type is not specified.\n */\nconst getHeaders = response => ({\n  'content-type': response.contentType || 'text/plain',\n  'content-length': response.contentLength || Buffer.byteLength(response.content)\n});\n\n/**\n * sendHead :: object -> object -> Either\n *\n * sendHead triggers responseHook.writeHead side effect and outputs Right(responseHook) on success.\n * sendHead triggers responseHook.writeHead side effect and outputs Left(string) on fail.\n * sendHead uses 200 as response status if no status is specified in the input response object.\n */\nconst sendHead = response => responseHook =>\n  Either.try(() =>\n    passThrough(\n      responseHook => responseHook.writeHead(response.status || 200, getHeaders(response))\n    )(responseHook)\n  );\n\n/**\n * sendContent :: object -> object -> Either\n *\n * sendContent triggers responseHook.end side effect and outputs Right(responseHook) on success.\n * sendContent triggers responseHook.end side effect and outputs Left(string) on fail.\n */\nconst sendContent = response => responseHook =>\n  Either.try(() =>\n    passThrough(\n      responseHook => isJust(response.content) ? responseHook.end(response.content) : responseHook.end()\n    )(responseHook)\n  );\n\n/**\n * streamFile :: object -> object -> Either\n *\n * streamFile triggers read data stream side effect streaming response.file and outputs Right(responseHook) on success.\n * streamFile triggers read data stream side effect streaming response.file and outputs Left(string) on fail.\n */\nconst streamFile = response => responseHook =>\n  fs.existsSync(response.file)\n    ? Either.Right(\n        passThrough(\n          responseHook => fs.createReadStream(response.file).pipe(responseHook)\n          // TODO: catch .on(\"error\", handler) for pipe\n        )(responseHook)\n      )\n    : Either.Left('File does not exist.');\n\n/**\n * sendOrStream :: object -> object -> Either\n *\n * sendOrStream outputs Either calling streamFile or sendContent depending on whether response.file is just.\n */\nconst sendOrStream = response => responseHook =>\n  isJust(response.file)\n    ? streamFile(response)(responseHook)\n    : sendContent(response)(responseHook);\n\n/**\n * ResponseEffect :: object -> object -> SyncEffect(() -> Either(object))\n *\n * ResponseEffect outputs SyncEffect which can trigger side effects responseHook.writeHead and responseHook.end outputting Right(responseHook) on success.\n * ResponseEffect outputs SyncEffect which can trigger side effects responseHook.writeHead and responseHook.end outputting Left(error) on fail.\n */\nconst ResponseEffect = responseHook => response =>\n  SyncEffect\n  .of(() =>\n    Either\n    .of(responseHook)\n    .flatMap(sendHead(response))\n    .flatMap(sendOrStream(response))\n  );\n\nexport default ResponseEffect;\n\nexport {\n  getHeaders,\n  sendHead,\n  sendContent,\n  streamFile,\n  sendOrStream\n}","import {SyncEffect, lowerCaseOf} from \"@7urtle/lambda\";\nimport http from \"http\";\nimport Router from \"./Router\";\nimport ResponseEffect from \"./ResponseEffect\";\n\n/**\n * getRequest :: object -> object\n *\n * getRequest extracts request data from input requestHook and outputs request object.\n */\nconst getRequest = requestHook => ({\n  path: requestHook.url,\n  method: lowerCaseOf(requestHook.method)\n});\n\n/**\n * getResponse :: object -> object -> object\n *\n * getResponse outputs response object depending on input configuration and requestHook.\n */\nconst getResponse = configuration => requestHook => Router.getResponse(configuration)(getRequest(requestHook));\n\n/**\n * onRequest :: object -> (object, object) -> Either\n *\n * onRequest outputs responseHook executing ResponseEffect side effect based on input configuration, requestHook and responseHook.\n */\nconst onRequest = configuration => (requestHook, responseHook) =>\n  ResponseEffect(responseHook)(getResponse(configuration)(requestHook))\n  .trigger();\n// TODO: I am not really processing what happens if onRequest fails... probably log it...\n\n/**\n * requestListener :: object -> Server -> Server\n *\n * requestListener reqisters onRequest handler to request listener and outputs Server.'\n */\nconst requestListener = configuration => Server => Server.on('request', onRequest(configuration));\n\n/**\n * listen :: object -> Server -> Server\n *\n * listen calls input Server listen function passing it configuration.port and outputs Server.\n */\nconst listen = configuration => Server => Server.listen(configuration.port);\n\n/**\n * Server :: object -> SyncEffect(http.Server)\n *\n * Server outputs results based on configuration.\n */\nconst Server = configuration =>\n  SyncEffect\n  .of(http.createServer)\n  .map(requestListener(configuration))\n  .map(listen(configuration));\n\nexport default Server;\n\nexport {\n  getRequest,\n  getResponse,\n  onRequest,\n  requestListener,\n  listen\n};","import {Either} from '@7urtle/lambda';\n\nconst any = request => Either.Right({\n  status: 404,\n  contentType: 'text/plain',\n  content: 'Not Found'\n});\n\nexport default {any};","import {Either, isEqual} from '@7urtle/lambda';\nimport fs from 'fs';\nimport mimeTypes from 'mime-types';\n\n/**\n * fileExists :: string -> object -> Either\n *\n * fileExists outputs Either of input request if file exists on input path or Either.Left of 404 if it does not.\n */\nconst fileExists = path => request => fs.existsSync(path) ? Either.Right(request) : Either.Left(404);\n\n/**\n * getResponse :: string -> object -> object\n *\n * getResponse outputs response object based on input file path.\n */\nconst getResponse = path => request => ({\n  status: 200,\n  file: isEqual('get')(request.method) ? path : '',\n  contentType: mimeTypes.lookup(path) || 'application/octet-stream',\n  contentLength: fs.statSync(path).size\n});\n\n/**\n * apiFile :: string -> object\n *\n * apiFile outputs api object with get call that outputs response object based on input file path.\n */\nconst apiFile = path => ({\n  get: request =>\n    Either\n    .of(request)\n    .flatMap(fileExists(path))\n    .map(getResponse(path))\n});\n\nexport default apiFile;\n\nexport {\n  fileExists,\n  getResponse\n};","import Server from \"./Server\";\nimport api404 from \"./apis/api404\";\nimport apiFile from './apis/apiFile';\n\nconst defaultConfiguration = {\n  port: process.env.port || 3000,\n  routes: [],\n  404: api404\n};\n\nconst start = configuration =>\n  Server({\n    ...defaultConfiguration,\n    ...configuration\n  })\n  .trigger();\n\nexport default {start};\n\nexport {\n  apiFile\n};"],"sourceRoot":""}