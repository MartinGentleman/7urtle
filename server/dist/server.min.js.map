{"version":3,"sources":["webpack://server/webpack/universalModuleDefinition","webpack://server/webpack/bootstrap","webpack://server/external \"fs\"","webpack://server/./node_modules/@babel/runtime/helpers/defineProperty.js","webpack://server/external \"http\"","webpack://server/./node_modules/query-string/index.js","webpack://server/./node_modules/mime-types/index.js","webpack://server/./node_modules/strict-uri-encode/index.js","webpack://server/./node_modules/decode-uri-component/index.js","webpack://server/./node_modules/split-on-first/index.js","webpack://server/./node_modules/mime-db/index.js","webpack://server/external \"path\"","webpack://server/./node_modules/@7urtle/lambda/src/conditional.js","webpack://server/./node_modules/@7urtle/lambda/src/utils.js","webpack://server/./node_modules/@7urtle/lambda/src/list.js","webpack://server/./node_modules/@7urtle/lambda/src/string.js","webpack://server/./node_modules/@7urtle/lambda/src/Maybe.js","webpack://server/./node_modules/@7urtle/lambda/src/Either.js","webpack://server/./node_modules/@7urtle/lambda/src/SyncEffect.js","webpack://server/./node_modules/@7urtle/lambda/src/AsyncEffect.js","webpack://server/./src/Router.js","webpack://server/./src/RequestEffect.js","webpack://server/./src/ResponseEffect.js","webpack://server/./src/Server.js","webpack://server/./src/apis/api404.js","webpack://server/./src/apis/apiError.js","webpack://server/./src/apis/apiFile.js","webpack://server/./src/index.js"],"names":["root","factory","exports","module","define","amd","this","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","require","obj","configurable","writable","strictUriEncode","decodeComponent","splitOnFirst","encode","options","strict","encodeURIComponent","decode","removeHash","input","hashStart","indexOf","slice","extract","queryStart","parse","formatter","result","arrayFormat","accumulator","exec","replace","undefined","concat","newValue","split","parserForArrayFormat","assign","sort","parseNumbers","parseBooleans","ret","trim","param","Number","isNaN","toLowerCase","keys","reduce","Boolean","Array","isArray","keysSorter","a","b","map","stringify","index","length","join","encoderForArrayFormat","filter","x","parseUrl","url","query","extensions","types","preference","db","extname","EXTRACT_TYPE_REGEXP","TEXT_TYPE_REGEXP","charset","type","match","mime","test","charsets","lookup","contentType","str","extension","exts","path","substr","forEach","from","source","to","charCodeAt","toString","toUpperCase","singleMatcher","RegExp","multiMatcher","decodeComponents","components","decodeURIComponent","err","left","right","tokens","encodedURI","TypeError","replaceMap","%FE%FF","%FF%FE","entries","customDecodeURIComponent","string","separator","separatorIndex","isEqual","isTypeOf","typeOf","isString","isNull","isUndefined","isObject","isFunction","isLength","lengthOf","isEmpty","isNothing","isNotLength","isNotEqual","isJust","passThrough","f","deepInspect","console","log","String","inspectFunction","inspectArray","inspect","k","keysOf","inspectObject","inspectString","mapper","list","lowerCaseOf","Maybe_Maybe","[object Object]","Nothing","Maybe_Just","fn","of","Either","Either_Right","Either_Left","e","message","SyncEffect_SyncEffect","trigger","flatMap","AsyncEffect_AsyncEffect","_","resolve","Promise","reject","findRoute","configuration","request","error","onJust","functorMaybe","maybe","Left","Right","Maybe","routes","find","route","substring","endsWith","startsWith","limit","start","getApiResultForError","any","emptyContent","resultEither","_objectSpread","contentLength","Buffer","byteLength","content","file","Router","isLeft","logger","catchApiError","catchApiException","api","method","getApiResult","getRequestObject","requestHook","data","json","JSON","queryString","RequestEffect","AsyncEffect","on","sendHead","response","responseHook","writeHead","status","content-type","content-length","getHeaders","sendOrStream","fs","existsSync","createReadStream","pipe","streamFile","end","sendContent","ResponseEffect","SyncEffect","resolveResponse","requestListener","Server","onRequest","http","createServer","listen","port","api404","apiError","apiFile","fileExists","mimeTypes","statSync","size","getResponse","info","defaultConfiguration","process","env","404","__webpack_exports__","src_objectSpread"],"mappings":"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","file":"server.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"server\"] = factory();\n\telse\n\t\troot[\"server\"] = factory();\n})(this, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 11);\n","module.exports = require(\"fs\");","function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nmodule.exports = _defineProperty;","module.exports = require(\"http\");","'use strict';\nconst strictUriEncode = require('strict-uri-encode');\nconst decodeComponent = require('decode-uri-component');\nconst splitOnFirst = require('split-on-first');\n\nfunction encoderForArrayFormat(options) {\n\tswitch (options.arrayFormat) {\n\t\tcase 'index':\n\t\t\treturn key => (result, value) => {\n\t\t\t\tconst index = result.length;\n\t\t\t\tif (value === undefined) {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\n\t\t\t\tif (value === null) {\n\t\t\t\t\treturn [...result, [encode(key, options), '[', index, ']'].join('')];\n\t\t\t\t}\n\n\t\t\t\treturn [\n\t\t\t\t\t...result,\n\t\t\t\t\t[encode(key, options), '[', encode(index, options), ']=', encode(value, options)].join('')\n\t\t\t\t];\n\t\t\t};\n\n\t\tcase 'bracket':\n\t\t\treturn key => (result, value) => {\n\t\t\t\tif (value === undefined) {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\n\t\t\t\tif (value === null) {\n\t\t\t\t\treturn [...result, [encode(key, options), '[]'].join('')];\n\t\t\t\t}\n\n\t\t\t\treturn [...result, [encode(key, options), '[]=', encode(value, options)].join('')];\n\t\t\t};\n\n\t\tcase 'comma':\n\t\t\treturn key => (result, value, index) => {\n\t\t\t\tif (value === null || value === undefined || value.length === 0) {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\n\t\t\t\tif (index === 0) {\n\t\t\t\t\treturn [[encode(key, options), '=', encode(value, options)].join('')];\n\t\t\t\t}\n\n\t\t\t\treturn [[result, encode(value, options)].join(',')];\n\t\t\t};\n\n\t\tdefault:\n\t\t\treturn key => (result, value) => {\n\t\t\t\tif (value === undefined) {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\n\t\t\t\tif (value === null) {\n\t\t\t\t\treturn [...result, encode(key, options)];\n\t\t\t\t}\n\n\t\t\t\treturn [...result, [encode(key, options), '=', encode(value, options)].join('')];\n\t\t\t};\n\t}\n}\n\nfunction parserForArrayFormat(options) {\n\tlet result;\n\n\tswitch (options.arrayFormat) {\n\t\tcase 'index':\n\t\t\treturn (key, value, accumulator) => {\n\t\t\t\tresult = /\\[(\\d*)\\]$/.exec(key);\n\n\t\t\t\tkey = key.replace(/\\[\\d*\\]$/, '');\n\n\t\t\t\tif (!result) {\n\t\t\t\t\taccumulator[key] = value;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (accumulator[key] === undefined) {\n\t\t\t\t\taccumulator[key] = {};\n\t\t\t\t}\n\n\t\t\t\taccumulator[key][result[1]] = value;\n\t\t\t};\n\n\t\tcase 'bracket':\n\t\t\treturn (key, value, accumulator) => {\n\t\t\t\tresult = /(\\[\\])$/.exec(key);\n\t\t\t\tkey = key.replace(/\\[\\]$/, '');\n\n\t\t\t\tif (!result) {\n\t\t\t\t\taccumulator[key] = value;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (accumulator[key] === undefined) {\n\t\t\t\t\taccumulator[key] = [value];\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\taccumulator[key] = [].concat(accumulator[key], value);\n\t\t\t};\n\n\t\tcase 'comma':\n\t\t\treturn (key, value, accumulator) => {\n\t\t\t\tconst isArray = typeof value === 'string' && value.split('').indexOf(',') > -1;\n\t\t\t\tconst newValue = isArray ? value.split(',') : value;\n\t\t\t\taccumulator[key] = newValue;\n\t\t\t};\n\n\t\tdefault:\n\t\t\treturn (key, value, accumulator) => {\n\t\t\t\tif (accumulator[key] === undefined) {\n\t\t\t\t\taccumulator[key] = value;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\taccumulator[key] = [].concat(accumulator[key], value);\n\t\t\t};\n\t}\n}\n\nfunction encode(value, options) {\n\tif (options.encode) {\n\t\treturn options.strict ? strictUriEncode(value) : encodeURIComponent(value);\n\t}\n\n\treturn value;\n}\n\nfunction decode(value, options) {\n\tif (options.decode) {\n\t\treturn decodeComponent(value);\n\t}\n\n\treturn value;\n}\n\nfunction keysSorter(input) {\n\tif (Array.isArray(input)) {\n\t\treturn input.sort();\n\t}\n\n\tif (typeof input === 'object') {\n\t\treturn keysSorter(Object.keys(input))\n\t\t\t.sort((a, b) => Number(a) - Number(b))\n\t\t\t.map(key => input[key]);\n\t}\n\n\treturn input;\n}\n\nfunction removeHash(input) {\n\tconst hashStart = input.indexOf('#');\n\tif (hashStart !== -1) {\n\t\tinput = input.slice(0, hashStart);\n\t}\n\n\treturn input;\n}\n\nfunction extract(input) {\n\tinput = removeHash(input);\n\tconst queryStart = input.indexOf('?');\n\tif (queryStart === -1) {\n\t\treturn '';\n\t}\n\n\treturn input.slice(queryStart + 1);\n}\n\nfunction parse(input, options) {\n\toptions = Object.assign({\n\t\tdecode: true,\n\t\tsort: true,\n\t\tarrayFormat: 'none',\n\t\tparseNumbers: false,\n\t\tparseBooleans: false\n\t}, options);\n\n\tconst formatter = parserForArrayFormat(options);\n\n\t// Create an object with no prototype\n\tconst ret = Object.create(null);\n\n\tif (typeof input !== 'string') {\n\t\treturn ret;\n\t}\n\n\tinput = input.trim().replace(/^[?#&]/, '');\n\n\tif (!input) {\n\t\treturn ret;\n\t}\n\n\tfor (const param of input.split('&')) {\n\t\tlet [key, value] = splitOnFirst(param.replace(/\\+/g, ' '), '=');\n\n\t\t// Missing `=` should be `null`:\n\t\t// http://w3.org/TR/2012/WD-url-20120524/#collect-url-parameters\n\t\tvalue = value === undefined ? null : decode(value, options);\n\n\t\tif (options.parseNumbers && !Number.isNaN(Number(value)) && (typeof value === 'string' && value.trim() !== '')) {\n\t\t\tvalue = Number(value);\n\t\t} else if (options.parseBooleans && value !== null && (value.toLowerCase() === 'true' || value.toLowerCase() === 'false')) {\n\t\t\tvalue = value.toLowerCase() === 'true';\n\t\t}\n\n\t\tformatter(decode(key, options), value, ret);\n\t}\n\n\tif (options.sort === false) {\n\t\treturn ret;\n\t}\n\n\treturn (options.sort === true ? Object.keys(ret).sort() : Object.keys(ret).sort(options.sort)).reduce((result, key) => {\n\t\tconst value = ret[key];\n\t\tif (Boolean(value) && typeof value === 'object' && !Array.isArray(value)) {\n\t\t\t// Sort object keys, not values\n\t\t\tresult[key] = keysSorter(value);\n\t\t} else {\n\t\t\tresult[key] = value;\n\t\t}\n\n\t\treturn result;\n\t}, Object.create(null));\n}\n\nexports.extract = extract;\nexports.parse = parse;\n\nexports.stringify = (object, options) => {\n\tif (!object) {\n\t\treturn '';\n\t}\n\n\toptions = Object.assign({\n\t\tencode: true,\n\t\tstrict: true,\n\t\tarrayFormat: 'none'\n\t}, options);\n\n\tconst formatter = encoderForArrayFormat(options);\n\tconst keys = Object.keys(object);\n\n\tif (options.sort !== false) {\n\t\tkeys.sort(options.sort);\n\t}\n\n\treturn keys.map(key => {\n\t\tconst value = object[key];\n\n\t\tif (value === undefined) {\n\t\t\treturn '';\n\t\t}\n\n\t\tif (value === null) {\n\t\t\treturn encode(key, options);\n\t\t}\n\n\t\tif (Array.isArray(value)) {\n\t\t\treturn value\n\t\t\t\t.reduce(formatter(key), [])\n\t\t\t\t.join('&');\n\t\t}\n\n\t\treturn encode(key, options) + '=' + encode(value, options);\n\t}).filter(x => x.length > 0).join('&');\n};\n\nexports.parseUrl = (input, options) => {\n\treturn {\n\t\turl: removeHash(input).split('?')[0] || '',\n\t\tquery: parse(extract(input), options)\n\t};\n};\n","/*!\n * mime-types\n * Copyright(c) 2014 Jonathan Ong\n * Copyright(c) 2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict'\n\n/**\n * Module dependencies.\n * @private\n */\n\nvar db = require('mime-db')\nvar extname = require('path').extname\n\n/**\n * Module variables.\n * @private\n */\n\nvar EXTRACT_TYPE_REGEXP = /^\\s*([^;\\s]*)(?:;|\\s|$)/\nvar TEXT_TYPE_REGEXP = /^text\\//i\n\n/**\n * Module exports.\n * @public\n */\n\nexports.charset = charset\nexports.charsets = { lookup: charset }\nexports.contentType = contentType\nexports.extension = extension\nexports.extensions = Object.create(null)\nexports.lookup = lookup\nexports.types = Object.create(null)\n\n// Populate the extensions/types maps\npopulateMaps(exports.extensions, exports.types)\n\n/**\n * Get the default charset for a MIME type.\n *\n * @param {string} type\n * @return {boolean|string}\n */\n\nfunction charset (type) {\n  if (!type || typeof type !== 'string') {\n    return false\n  }\n\n  // TODO: use media-typer\n  var match = EXTRACT_TYPE_REGEXP.exec(type)\n  var mime = match && db[match[1].toLowerCase()]\n\n  if (mime && mime.charset) {\n    return mime.charset\n  }\n\n  // default text/* to utf-8\n  if (match && TEXT_TYPE_REGEXP.test(match[1])) {\n    return 'UTF-8'\n  }\n\n  return false\n}\n\n/**\n * Create a full Content-Type header given a MIME type or extension.\n *\n * @param {string} str\n * @return {boolean|string}\n */\n\nfunction contentType (str) {\n  // TODO: should this even be in this module?\n  if (!str || typeof str !== 'string') {\n    return false\n  }\n\n  var mime = str.indexOf('/') === -1\n    ? exports.lookup(str)\n    : str\n\n  if (!mime) {\n    return false\n  }\n\n  // TODO: use content-type or other module\n  if (mime.indexOf('charset') === -1) {\n    var charset = exports.charset(mime)\n    if (charset) mime += '; charset=' + charset.toLowerCase()\n  }\n\n  return mime\n}\n\n/**\n * Get the default extension for a MIME type.\n *\n * @param {string} type\n * @return {boolean|string}\n */\n\nfunction extension (type) {\n  if (!type || typeof type !== 'string') {\n    return false\n  }\n\n  // TODO: use media-typer\n  var match = EXTRACT_TYPE_REGEXP.exec(type)\n\n  // get extensions\n  var exts = match && exports.extensions[match[1].toLowerCase()]\n\n  if (!exts || !exts.length) {\n    return false\n  }\n\n  return exts[0]\n}\n\n/**\n * Lookup the MIME type for a file path/extension.\n *\n * @param {string} path\n * @return {boolean|string}\n */\n\nfunction lookup (path) {\n  if (!path || typeof path !== 'string') {\n    return false\n  }\n\n  // get the extension (\"ext\" or \".ext\" or full path)\n  var extension = extname('x.' + path)\n    .toLowerCase()\n    .substr(1)\n\n  if (!extension) {\n    return false\n  }\n\n  return exports.types[extension] || false\n}\n\n/**\n * Populate the extensions and types maps.\n * @private\n */\n\nfunction populateMaps (extensions, types) {\n  // source preference (least -> most)\n  var preference = ['nginx', 'apache', undefined, 'iana']\n\n  Object.keys(db).forEach(function forEachMimeType (type) {\n    var mime = db[type]\n    var exts = mime.extensions\n\n    if (!exts || !exts.length) {\n      return\n    }\n\n    // mime -> extensions\n    extensions[type] = exts\n\n    // extension -> mime\n    for (var i = 0; i < exts.length; i++) {\n      var extension = exts[i]\n\n      if (types[extension]) {\n        var from = preference.indexOf(db[types[extension]].source)\n        var to = preference.indexOf(mime.source)\n\n        if (types[extension] !== 'application/octet-stream' &&\n          (from > to || (from === to && types[extension].substr(0, 12) === 'application/'))) {\n          // skip the remapping\n          continue\n        }\n      }\n\n      // set the extension -> mime\n      types[extension] = type\n    }\n  })\n}\n","'use strict';\nmodule.exports = str => encodeURIComponent(str).replace(/[!'()*]/g, x => `%${x.charCodeAt(0).toString(16).toUpperCase()}`);\n","'use strict';\nvar token = '%[a-f0-9]{2}';\nvar singleMatcher = new RegExp(token, 'gi');\nvar multiMatcher = new RegExp('(' + token + ')+', 'gi');\n\nfunction decodeComponents(components, split) {\n\ttry {\n\t\t// Try to decode the entire string first\n\t\treturn decodeURIComponent(components.join(''));\n\t} catch (err) {\n\t\t// Do nothing\n\t}\n\n\tif (components.length === 1) {\n\t\treturn components;\n\t}\n\n\tsplit = split || 1;\n\n\t// Split the array in 2 parts\n\tvar left = components.slice(0, split);\n\tvar right = components.slice(split);\n\n\treturn Array.prototype.concat.call([], decodeComponents(left), decodeComponents(right));\n}\n\nfunction decode(input) {\n\ttry {\n\t\treturn decodeURIComponent(input);\n\t} catch (err) {\n\t\tvar tokens = input.match(singleMatcher);\n\n\t\tfor (var i = 1; i < tokens.length; i++) {\n\t\t\tinput = decodeComponents(tokens, i).join('');\n\n\t\t\ttokens = input.match(singleMatcher);\n\t\t}\n\n\t\treturn input;\n\t}\n}\n\nfunction customDecodeURIComponent(input) {\n\t// Keep track of all the replacements and prefill the map with the `BOM`\n\tvar replaceMap = {\n\t\t'%FE%FF': '\\uFFFD\\uFFFD',\n\t\t'%FF%FE': '\\uFFFD\\uFFFD'\n\t};\n\n\tvar match = multiMatcher.exec(input);\n\twhile (match) {\n\t\ttry {\n\t\t\t// Decode as big chunks as possible\n\t\t\treplaceMap[match[0]] = decodeURIComponent(match[0]);\n\t\t} catch (err) {\n\t\t\tvar result = decode(match[0]);\n\n\t\t\tif (result !== match[0]) {\n\t\t\t\treplaceMap[match[0]] = result;\n\t\t\t}\n\t\t}\n\n\t\tmatch = multiMatcher.exec(input);\n\t}\n\n\t// Add `%C2` at the end of the map to make sure it does not replace the combinator before everything else\n\treplaceMap['%C2'] = '\\uFFFD';\n\n\tvar entries = Object.keys(replaceMap);\n\n\tfor (var i = 0; i < entries.length; i++) {\n\t\t// Replace all decoded components\n\t\tvar key = entries[i];\n\t\tinput = input.replace(new RegExp(key, 'g'), replaceMap[key]);\n\t}\n\n\treturn input;\n}\n\nmodule.exports = function (encodedURI) {\n\tif (typeof encodedURI !== 'string') {\n\t\tthrow new TypeError('Expected `encodedURI` to be of type `string`, got `' + typeof encodedURI + '`');\n\t}\n\n\ttry {\n\t\tencodedURI = encodedURI.replace(/\\+/g, ' ');\n\n\t\t// Try the built in decoder first\n\t\treturn decodeURIComponent(encodedURI);\n\t} catch (err) {\n\t\t// Fallback to a more advanced decoder\n\t\treturn customDecodeURIComponent(encodedURI);\n\t}\n};\n","'use strict';\n\nmodule.exports = (string, separator) => {\n\tif (!(typeof string === 'string' && typeof separator === 'string')) {\n\t\tthrow new TypeError('Expected the arguments to be of type `string`');\n\t}\n\n\tif (separator === '') {\n\t\treturn [string];\n\t}\n\n\tconst separatorIndex = string.indexOf(separator);\n\n\tif (separatorIndex === -1) {\n\t\treturn [string];\n\t}\n\n\treturn [\n\t\tstring.slice(0, separatorIndex),\n\t\tstring.slice(separatorIndex + separator.length)\n\t];\n};\n","/*!\n * mime-db\n * Copyright(c) 2014 Jonathan Ong\n * MIT Licensed\n */\n\n/**\n * Module exports.\n */\n\nmodule.exports = require('./db.json')\n","module.exports = require(\"path\");","import {typeOf, lengthOf} from \"./utils\";\n\n/**\n * isEqual :: a -> b -> boolean\n *\n * isEqual output is true if strict equality between a and b is true.\n * isEqual output is always false for comparison of objects and arrays.\n */\nexport const isEqual = a => b => a === b;\n\n/**\n * isNotEqual :: a -> b -> boolean\n *\n * isNotEqual output is true if strict equality between a and b is false.\n * isNotEqual output is always true for comparison of objects and arrays.\n */\nexport const isNotEqual = a => b => a !== b;\n\n/**\n * isTrue :: a -> boolean\n *\n * isTrue output is true if input is true.\n */\nexport const isTrue = isEqual(true);\n\n/**\n * isFalse :: a -> Boolean\n *\n * isFalse output is true if input is false.\n */\nexport const isFalse = isEqual(false);\n\n/**\n * isGreaterThan :: a -> b -> boolean\n *\n * isGreaterThan output is true if b is greater than a.\n */\nexport const isGreaterThan = a => b => b > a;\n\n/**\n * isLessThan :: a -> b -> boolean\n *\n * isLessThan output is true if b is less than a.\n */\nexport const isLessThan = a => b => b < a;\n\n/**\n * isAtLeast :: a -> b -> boolean\n *\n * isAtLeast output is true if b is greater or equal to a.\n */\nexport const isAtLeast = a => b => b >= a;\n\n/**\n * isAtMost :: a -> b -> boolean\n *\n * isAtMost output is true if b is less or equal to a.\n */\nexport const isAtMost = a => b => b <= a;\n\n/**\n * isTypeOf :: a -> b -> boolean\n *\n * isTypeOf output is true if b is a type of a.\n */\nexport const isTypeOf = a => b => isEqual(typeOf(b))(a);\n\n/**\n * isString :: a -> boolean\n *\n * isString output is true if b is a string.\n */\nexport const isString = isTypeOf('string');\n\n/**\n * isBoolean :: a -> boolean\n *\n * isBoolean output is true if b is a boolean.\n */\nexport const isBoolean = isTypeOf('boolean');\n\n/**\n * isNull :: a -> boolean\n *\n * isNull output is true if b is a null.\n */\nexport const isNull = isEqual(null);\n\n/**\n * isUndefined :: a -> boolean\n *\n * isUndefined output is true if b is an undefined.\n */\nexport const isUndefined = isTypeOf('undefined');\n\n/**\n * isNumber :: a -> boolean\n *\n * isNumber output is true if b is a number.\n */\nexport const isNumber = isTypeOf('number');\n\n/**\n * isObject :: a -> boolean\n *\n * isObject output is true if b is an object, array of null.\n */\nexport const isObject = isTypeOf('object');\n\n/**\n * isArray :: a -> boolean\n *\n * isArray output is true if b is an array.\n */\nexport const isArray = Array.isArray;\n\n/**\n * isFunction :: a -> boolean\n *\n * isFunction output is true if b is a function.\n */\nexport const isFunction = isTypeOf('function');\n\n/**\n * isLength :: (string|array) -> b -> boolean\n *\n * isLength output is true if b is a length of a.\n */\nexport const isLength = a => b => isEqual(lengthOf(b))(a);\n\n/**\n * isNotLength :: (string|array) -> b -> boolean\n *\n * isNotLength output is true if b is not a length of a.\n */\nexport const isNotLength = a => b => !isLength(a)(b);\n\n/**\n * isEmpty :: (string|array) -> boolean\n *\n * isEmpty output is true if input has a length of 0.\n * isEmpty output is always false if input is an object and not an array or a string.\n */\nexport const isEmpty = isLength(0);\n\n/**\n * isNotEmpty :: (string|array) -> boolean\n *\n * isNotEmpty output is true if input does not have a length of 0.\n * isNotEmpty output is always true if input is an object and not an array or a string.\n */\nexport const isNotEmpty = isNotLength(0);\n\n/**\n * isZero :: a -> boolean\n *\n * isZero output is true if a is 0.\n */\nexport const isZero = isEqual(0);\n\n/**\n * isNotZero :: a -> boolean\n *\n * isNotZero output is true if a is not 0.\n */\nexport const isNotZero = isNotEqual(0);\n\n/**\n * isNothing :: a -> boolean\n *\n * isNothing returns true if input is null, undefined or empty string or empty array.\n */\nexport const isNothing = a => isNull(a) || isUndefined(a) || isEmpty(a);\n\n/**\n * isJust :: a -> boolean\n *\n * isJust returns true if input is not null, undefined or empty string or empty array.\n */\nexport const isJust = a => !isNothing(a);","import {isArray, isEqual, isString, isObject, isFunction, isNull, isUndefined} from \"./conditional\";\nimport {keysOf, join, map} from \"./list\";\n\n/**\n * typeOf :: a -> string\n *\n * typeOf outputs type of its input a.\n */\nexport const typeOf = a => typeof a;\n\n/**\n * lengthOf :: (string|array) -> number\n */\nexport const lengthOf = a => a.length;\n\n/**\n * passThrough :: function -> a -> a\n *\n * passThrough output is the same as input a.\n * passThrough executes function passed as first argument.\n */\nexport const passThrough = f => a => {\n  f(a);\n  return a;\n};\n\n/**\n * log :: a -> a\n *\n * log output is the same as input.\n * log causes side effect of console.log.\n */\nexport const log = passThrough(console.log);\n\n/**\n * spy :: a -> a\n *\n * spy output is the same as input.\n * spy causes side effect of console.log.\n */\nexport const spy = passThrough(a => console.log(deepInspect(a)));\n\n/**\n * minusOneToUndefined :: a -> a|boolean\n *\n * minusOneToUndefined output is the same as input or undefined if input is -1.\n */\nexport const minusOneToUndefined = a => isEqual(-1)(a) ? undefined: a;\n\n/**\n * inspectFunction :: (a -> b) -> string\n *\n * inspectFunction outputs name of named function or its conversion to string.\n */\nexport const inspectFunction = f => f.name ? f.name : String(f);\n\n/**\n * inspectArray :: [a] -> string\n *\n * inspectArray maps over input array [a] and outputs string representing it.\n */\nexport const inspectArray = a => `[${join(', ')(map(deepInspect)(a))}]`;\n\n/**\n * inspectString :: a -> string\n *\n * inspectString outputs string representing input.\n */\nexport const inspectString = a => `'${a}'`;\n\n/**\n * inspectObject :: a -> string\n *\n * inspectObject outputs string representing input.\n */\nexport const inspectObject = a =>\n  isFunction(a.inspect)\n    ? a.inspect()\n    : `{${join(', ')(map(join(': '))(map(k => [k, deepInspect(a[k])])(keysOf(a))))}}`\n\n/**\n * deepInspect :: a -> string\n *\n * deepInspect runs recursively over input and outputs string representing the input.\n */\nexport const deepInspect = a =>\n  isUndefined(a)\n    ? 'undefined'\n    : isNull(a)\n      ? 'null'\n      : isFunction(a)\n        ? inspectFunction(a)\n        : isArray(a)\n          ? inspectArray(a)\n          : isObject(a)\n            ? inspectObject(a)\n            : isString(a)\n              ? inspectString(a)\n              : String(a);","import {minusOneToUndefined} from './utils';\n\n/**\n * reduce :: a -> ((a, b) -> a) -> [b] -> a\n *\n * reduce executes input reducer function that over each member of input array [b] to output single value a.\n *\n * reduce executes functions in reverse order to reduceRight.\n */\nexport const reduce = initial => reducer => list => list.reduce(reducer, initial);\n\n/**\n * reduceRight :: a -> ((a, b) -> a) -> [b] -> a\n *\n * reduceRight executes input reducer function that over each member of input array [b] to output single value a.\n *\n * reduceRight executes functions in reverse order to reduce.\n */\nexport const reduceRight = initial => reducer => list => list.reduceRight(reducer, initial);\n\n/**\n * map :: (a -> b) -> [a] -> [b]\n *\n * map executes input mapper over each member of input array [a] to output new array [b].\n */\nexport const map = mapper => list => list.map(mapper);\n\n/**\n * filter :: (a -> boolean) -> [a] -> [b]\n *\n * filter executes input checker over each member of input array [a] to filter and output filtered new array [b].\n */\nexport const filter = checker => list => list.filter(checker);\n\n/**\n * find :: (a -> boolean) -> [a] -> [b]\n *\n * find executes input checker over each member of input array [a] and outputs the first array member that matches checker or undefined.\n */\nexport const find = checker => list => list.find(checker);\n\n/**\n * findIndex :: (a -> boolean) -> [a] -> [b]\n *\n * findIndex executes input checker over each member of input array [a] and outputs the index of first array member that matches checker or undefined.\n */\nexport const findIndex = checker => list => minusOneToUndefined(list.findIndex(checker));\n\n/**\n * join :: string -> [a] -> string\n *\n * join outputs a string created by joining input array members with input separator.\n */\nexport const join = separator => list => list.join(separator);\n\n/**\n * keysOf :: object -> [string]\n *\n * keysOf outputs array of string keys of input array or object.\n */\nexport const keysOf = Object.keys;\n\n/**\n * entriesOf :: object -> [[string, a]]\n *\n * entriesOf outputs array of arrays of string keys and raw values of input array or object.\n */\nexport const entriesOf = Object.entries;\n\n/**\n * everyOf :: (a -> boolean) -> [a] -> boolean\n *\n * everyOf outputs true if every element of input array passes input checker function as true.\n */\nexport const everyOf = checker => list => list.every(checker);\n\n/**\n * slice :: number -> number -> [a] -> [a]\n *\n * slice outputs selected array elements as an array based on input range.\n */\nexport const slice = end => start => list => list.slice(start, end);\n\n/**\n * some :: (a -> boolean) -> [a] -> boolean\n *\n * some outputs true if any element of input array passes input checker function as true.\n */\nexport const someOf = checker => list => list.some(checker);","import {minusOneToUndefined} from './utils';\n\n/**\n * trim :: string -> string\n *\n * trim output is a string without white characters around it.\n */\nexport const trim = string => string.trim();\n\n/**\n * testRegEx :: regex -> string -> boolean\n *\n * testRegEx outputs true if string b passes regular expression a.\n */\nexport const testRegEx = regex => string => regex.test(string);\n\n/**\n * substr :: number -> number -> string -> string\n * \n * substr outputs substring based on provided string, start and limit.\n */\nexport const substr = limit => start => string => string.substr(start, limit);\n\n/**\n * startsWith :: string -> string -> boolean\n * \n * startsWith outputs true if an input string starts with provided string.\n */\nexport const startsWith = substring => string => string.startsWith(substring);\n\n/**\n * endsWith :: string -> string -> boolean\n * \n * endsWith outputs true if an input string ends with provided string.\n */\nexport const endsWith = substring => string => string.endsWith(substring);\n\n/**\n * repeat :: number -> string -> string\n * \n * repeat outputs new string repeating input string inputed count of times.\n */\nexport const repeat = count => string => string.repeat(count);\n\n/**\n * replace :: string -> string -> string -> string\n * \n * replace outputs new string replacing input substring with input replacement string in input string.\n */\nexport const replace = replacement => substring => string => string.replace(substring, replacement);\n\n/**\n * search :: string/regex -> string -> number\n * \n * search outputs position of input substring or regular expression withing input string or undefined if it is not found.\n */\nexport const search = substring => string => minusOneToUndefined(string.search(substring));\n\n/**\n * split :: string -> string -> array\n * \n * split outputs and array of an input string split by the input substring.\n */\nexport const split = substring => string => string.split(substring);\n\n/**\n * lowerCaseOf :: string -> string\n * \n * lowerCaseOf ouputs the lower case version of input string.\n */\nexport const lowerCaseOf = string => string.toLowerCase();\n\n/**\n * upperCaseOf :: string -> string\n * \n * upperCaseOf ouputs the upper case version of input string.\n */\nexport const upperCaseOf = string => string.toUpperCase();","import {deepInspect} from \"./utils\";\nimport {isNothing} from \"./conditional\";\n\n/**\n * Maybe.of() outputs instance of Maybe.\n * Maybe.of(a).inspect() outputs string Just(a) or Nothing.\n * Maybe.of(a) outputs Nothing for an input that is null, undefined, an empty string or an empty array.\n * Maybe.of(a) outputs Just for an input a that is not Nothing.\n * Maybe.of(a) outputs Nothing for an input a that is null or undefined.\n * Maybe.of(a).isJust() of an input a outputs true for a value that is Just.\n * Maybe.of(a).isNothing() of an input a outputs true for a value that is Nothing.\n * Maybe.of(a).map(a -> b) executes function over Maybe input a.\n * Maybe.of(a).map(a -> Just) outputs Just(Just).\n * Maybe.of(a).map(a -> b) does not execute over Nothing.\n * Maybe.of(a).flatMap(a -> b) executes function over Maybe input a returns its raw value.\n * Maybe.of(a).flatMap(a -> b) does not execute over Nothing.\n * Maybe.of(a).map(a -> b).ap(Maybe) provides applicative ability to apply functors to each other.\n * Maybe.of(Maybe -> Maybe -> c).ap(Maybe).ap(Maybe) provides applicative interface for a functor of a function.\n */\nexport class Maybe {\n  constructor(x) {\n    this.value = x;\n  }\n\n  static of(x) {\n    return isNothing(x) ? new Nothing(x) : new Just(x) ;\n  }\n}\n\nclass Just extends Maybe {\n  inspect() {\n    return `Just(${deepInspect(this.value)})`;\n  }\n\n  isNothing() {\n    return false;\n  }\n\n  isJust() {\n    return true;\n  }\n\n  map(fn) {\n    return Maybe.of(fn(this.value));\n  }\n\n  flatMap(fn) {\n    return fn(this.value);\n  }\n\n  ap(f) {\n    return f.map(this.value);\n  }\n}\n\nclass Nothing extends Maybe {\n  inspect () {\n    return 'Nothing';\n  }\n\n  isNothing() {\n    return true\n  }\n\n  isJust() {\n    return false;\n  }\n\n  map(fn) {\n    return this;\n  }\n\n  flatMap(fn) {\n    return this;\n  }\n\n  ap(f) {\n    return this;\n  }\n}\n\n/**\n * maybe :: a -> (b -> c) -> Maybe\n *\n * maybe outputs result of a function onJust if input Maybe is Just or outputs input error if input Maybe is Nothing.\n */\nexport const maybe = error => onJust => functorMaybe =>\n  functorMaybe.isNothing()\n    ? error\n    : onJust(functorMaybe.value);","import {deepInspect} from \"./utils\";\n\n/**\n * Either.of() outputs instance of Either.\n * Either.of(a) outputs instance of Right holding its input value.\n * Either.Right(a) outputs instance of Right holding its input value.\n * Either.Left(a) outputs instance of Left holding its input value.\n * Either.of(a).inspect() outputs string Right(a).\n * Either.Right(a).inspect() outputs string Right(a).\n * Either.Left(a).inspect() outputs string Left(a).\n * Either.of(a).isRight() always outputs true.\n * Either.Left(a).isLeft() outputs false if Either is Left.\n * Either.try(a -> b) outputs Right(b) if no error is thrown.\n * Either.try(a -> b) outputs Left(e.message) if error is thrown.\n * Either.of(a).map(a -> b) executes function over Either input a.\n * Either.of(a).map(a -> Right) outputs Right(Right).\n * Either.Left(a).map(a -> b) does not execute provided function and retains Left input value.\n * Either.of(a).flatMap(a -> b) executes function over Either input a returns its raw value through flatten.\n * Either.Left(a).flatMap(a -> b) does not execute provided function and retains Left input value.\n * Either.of(Either -> Either -> c).ap(Either).ap(Either) provides applicative interface.\n */\nexport class Either {\n  constructor(x) {\n    this.value = x;\n  }\n\n  static of(x) {\n    return new Right(x);\n  }\n\n  static Right(x) {\n    return new Right(x);\n  }\n\n  static Left(x) {\n    return new Left(x);\n  }\n\n  static try(fn) {\n    try {\n      return new Right(fn());\n    } catch(e) {\n      return new Left(e.message);\n    }\n  }\n}\n\nclass Right extends Either {\n  inspect() {\n    return `Right(${deepInspect(this.value)})`;\n  }\n\n  isLeft() {\n    return false;\n  }\n\n  isRight() {\n    return true;\n  }\n\n  map(fn) {\n    return Either.of(fn(this.value));\n  }\n\n  flatMap(fn) {\n    return fn(this.value);\n  }\n\n  ap(f) {\n    return f.map(this.value);\n  }\n}\n\nclass Left extends Either {\n  inspect() {\n    return `Left(${deepInspect(this.value)})`;\n  }\n\n  isLeft() {\n    return true;\n  }\n\n  isRight() {\n    return false;\n  }\n\n  map() {\n    return this;\n  }\n\n  flatMap() {\n    return this;\n  }\n\n  ap() {\n    return this;\n  }\n}\n\n/**\n * either :: (a -> b) -> (b -> c) -> Either\n *\n * either outputs result of a function onRight if input Either is Right or outputs result of a function onLeft if input Either is Left.\n */\nexport const either = onLeft => onRight => functorEither =>\n  functorEither.isLeft()\n    ? onLeft(functorEither.value)\n    : onRight(functorEither.value);","import {deepInspect} from \"./utils\";\n\n/**\n * SyncEffect.of() outputs instance of SyncEffect.\n * SyncEffect.wrap(a) is equal to SyncEffect.of(() -> a).\n * SyncEffect.of(() -> a).inspect() outputs string SyncEffect(a).\n * SyncEffect.of(() -> a).trigger() executes function provided as input of SyncEffect.\n * SyncEffect.of(() -> a).map(b -> c) composes function over SyncEffect input function.\n * SyncEffect.of(() -> a).map(b -> SyncEffect) outputs SyncEffect(SyncEffect).\n * SyncEffect.of(() -> a).flatMap(b -> SyncEffect) outputs SyncEffect.\n * SyncEffect.of(() -> a).map(a -> b).ap(SyncEffect) provides applicative ability to apply functors to each other.\n * SyncEffect.of(SyncEffect -> SyncEffect -> c).ap(SyncEffect).ap(SyncEffect) provides applicative interface for a functor of a function.\n * No input function is executed until trigger is called.\n */\nexport class SyncEffect {\n  constructor(fn) {\n    this.trigger = fn;\n  }\n\n  inspect() {\n    return `SyncEffect(${deepInspect(this.trigger)})`;\n  }\n\n  static of(x) {\n    return new SyncEffect(x);\n  }\n\n  static wrap(x) {\n    return new SyncEffect(() => x);\n  }\n\n  map(fn) {\n    return new SyncEffect(a => fn(this.trigger(a)));\n  }\n\n  flatMap(fn) {\n    return new SyncEffect(() => {\n      return this.map(fn).trigger().trigger();\n    })\n  }\n\n  ap(f) {\n    return this.flatMap(fn => f.map(fn));\n  }\n}","import {deepInspect} from \"./utils\";\n\n/**\n * AsyncEffect.of() outputs instance of AsyncEffect.\n * AsyncEffect.of(() -> a).inspect() outputs string AsyncEffect(a).\n * AsyncEffect.wrap(a) is equal to AsyncEffect.of((_, resolve) -> resolve(a)).\n * AsyncEffect.of((a, b) -> c).promise() outputs JavaScript promise.\n * AsyncEffect.of((a, b) -> c).trigger(d -> e, f -> g) for resolving async function resolves.\n * AsyncEffect.of((a, b) -> c).trigger(d -> e, f -> g) for rejecting async function rejects.\n * AsyncEffect.of((a, b) -> c).map(b -> c) composes function over AsyncEffect input function.\n * AsyncEffect.of((a, b) -> c).map(b -> AsyncEffect) outputs AsyncEffect(AsyncEffect).\n * AsyncEffect.of((a, b) -> c).flatMap(b -> AsyncEffect) outputs AsyncEffect.\n * AsyncEffect.of((a, b) -> c).map(a -> b).ap(AsyncEffect) provides applicative ability to apply functors to each other.\n * AsyncEffect.of(AsyncEffect -> AsyncEffect -> c).ap(AsyncEffect).ap(AsyncEffect) provides applicative interface for a functor of a function.\n * No input function is executed until trigger is called.\n */\nexport class AsyncEffect {\n  constructor(fn) {\n    this.trigger = fn;\n  }\n\n  inspect() {\n    return `AsyncEffect(${deepInspect(this.trigger)})`;\n  }\n\n  static of(x) {\n    return new AsyncEffect(x);\n  }\n\n  static wrap(x) {\n    return new AsyncEffect((_, resolve) => resolve(x));\n  }\n\n  promise() {\n    return new Promise((resolve, reject) => this.trigger(reject, resolve));\n  }\n\n  map(fn) {\n    return new AsyncEffect((reject, resolve) => this.trigger(reject, a => resolve(fn(a))));\n  }\n\n  flatMap(fn) {\n    return new AsyncEffect((reject, resolve) => this.trigger(reject, x => fn(x).trigger(reject, resolve)));\n  }\n\n  ap(f) {\n    return this.flatMap(fn => f.map(fn));\n  }\n}","import {isEqual, isFunction, isUndefined, maybe, Maybe, Either, endsWith, startsWith, substr, lengthOf} from \"@7urtle/lambda\";\n\n/**\n * checkRoute :: string -> object -> boolean\n *\n * checkRoute outputs true if inputs path and route.path match.\n * checkRoute supports /* routes.\n */\nconst checkRoute = path => route =>\n  endsWith('/*')(route.path)\n    ? startsWith(substr(lengthOf(route.path) -2)(0)(route.path))(path)\n    : isEqual(route.path)(path);\n\n/**\n * findRoute :: object -> object -> (object|undefined)\n *\n * findRoute outputs route object found in input configuration.routes based on input request.path or undefined if no path matches.\n */\nconst findRoute = configuration => request =>\n  maybe(Either.Left(404))\n       (Either.Right)\n       (Maybe.of(configuration.routes.find(checkRoute(request.path))));\n\n/**\n * getApiResultForError :: object -> object -> Either -> Either\n *\n * getApiResultForError outputs Either of error api call result for the error status defaulting to general error api.\n */\nconst getApiResultForError = configuration => request => error =>\n  !isUndefined(configuration[error.value]) && isFunction(configuration[error.value].any) // is there an api for the error?\n    ? configuration[error.value].any(request) // call api for the error\n    : configuration.error.any(request); // call api for general error\n\n/**\n * catchApiException :: object -> object -> Either -> Either\n *\n * catchApiException outputs the same Either or Either of 500 error call if input Either caught an exception.\n */\nconst catchApiException = configuration => request => result =>\n  result.isLeft()\n    ? configuration.logger.error(result.value) && Either.Right(configuration.error.any(request))\n    : result;\n\n/**\n * emptyContent :: Either -> Either\n *\n * emptyContent outputs Either of result with empty file and content based on input Either.\n */\nconst emptyContent = resultEither => resultEither.map(result => ({\n  ...result,\n  contentLength: result.contentLength || Buffer.byteLength(result.content),\n  file: '',\n  content: ''\n}));\n\n/**\n * getApiResult :: object -> object -> Either -> Either\n *\n * getApiResult outputs Either of api call result.\n * getApiResult if head is not api call it outputs Either of api call for get or any with empty file and content result or 404 result if neither are found.\n * getApiResult outputs Either of api 404 error call if route is not found.\n * getApiResult outputs Either of api any call if requested method call is not found.\n * getApiResult outputs Either of 404 api call if both requested method call and any call are not found.\n * getApiResult outputs Left of error code if api call returns Left.\n */\nconst getApiResult = configuration => request => route =>\n  route.isLeft() // was route not found?\n    ? getApiResultForError(configuration)(request)(route) // get api result for error\n    : isFunction(route.value.api[request.method]) // is there api call for the request method?\n      ? route.value.api[request.method](request) // call api for the request method\n      : isEqual(request.method)('head') // is request method HEAD?\n        ? isFunction(route.value.api.get) // can I use get instead of head\n          ? emptyContent(route.value.api.get(request)) // use get instead of head\n          : isFunction(route.value.api.any) // can I used any instead of head\n            ? emptyContent(route.value.api.any(request)) // use any instead of head\n            : emptyContent(configuration[404].any(request)) // call api for 404 error\n        : isFunction(route.value.api.any) // is there api any function?\n          ? route.value.api.any(request) // call api any function\n          : configuration[404].any(request); // call api for 404 error\n\n/**\n * catchApiError :: object -> object -> Either -> Either\n *\n * catchApiError outputs Either of error api call result for the error status or original input result.\n */\nconst catchApiError = configuration => request => result =>\n  result.isLeft()\n    ? configuration.logger.error(result.value) && getApiResultForError(configuration)(request)(result)\n    : result;\n\n/**\n * getResponse :: object -> object -> object\n *\n * getResponse outputs response object.\n * getResponse outputs response object for 404 api call if route is not found.\n * getResponse outputs response object for error api call if api call returns an error.\n * getResponse outputs response object for error api call if api call throws an exception.\n */\nconst getResponse = configuration => request =>\n  catchApiError(configuration)(request)( // we convert left api call result into error api call result\n    catchApiException(configuration)(request)( // we convert thrown exception into 500 error api call result\n      Either.try( // we use Either.try to catch thrown exceptions\n        () => getApiResult(configuration)(request)( // we call api associated with the found route\n          findRoute(configuration)(request) // first we find the right route or left 404\n        )\n      )\n    ).value\n  ).value;\n\nexport default {getResponse};\n\nexport {\n  checkRoute,\n  findRoute,\n  getApiResultForError,\n  catchApiException,\n  emptyContent,\n  getApiResult,\n  catchApiError\n};","import {AsyncEffect, Either, lowerCaseOf, isNothing} from \"@7urtle/lambda\";\nimport * as queryString from 'query-string';\n\n/**\n * parseJSON :: String -> Either\n *\n * parseJSON parses into String to JSON returning Either functor with the result\n */\nconst parseJSON = data => Either.try(() => JSON.parse(data));\n\n/**\n * getRequestObject :: object -> object\n *\n * getRequestObject extracts request data from input requestHook and outputs request object.\n */\nconst getRequestObject = requestHook => ({\n  path: requestHook.url,\n  method: lowerCaseOf(requestHook.method),\n  data: isNothing(requestHook.data)\n    ? undefined\n    : (json =>\n        json.isLeft()\n          ? queryString.parse(requestHook.data)\n          : json.value\n    )(parseJSON(requestHook.data))\n});\n\n/**\n * RequestEffect :: object -> AsyncEffect(() -> object)\n *\n * RequestEffect(object).trigger(d -> e, f -> g) for GET requestHook returns correct request object.\n * RequestEffect(object).trigger(d -> e, f -> g) for POST requestHook returns correct request object including data.\n */\nconst RequestEffect = requestHook =>\n  AsyncEffect.of(\n    (reject, resolve) => {\n      requestHook.data = '';\n      requestHook.on('data',\n        input => requestHook.data += input\n        // consider using stream-meter https://stackoverflow.com/questions/4295782/how-to-process-post-data-in-node-js\n      );\n      requestHook.on('end',\n        () => resolve(requestHook)\n      );\n    }\n  )\n  .map(getRequestObject);\n\nexport default RequestEffect;\n\nexport {\n  getRequestObject\n};","import {SyncEffect, Either, passThrough, isJust} from \"@7urtle/lambda\";\nimport fs from \"fs\";\n\n/**\n * getHeaders :: object -> object\n *\n * getHeaders creates headers object out of response object.\n * getHeaders uses text/plain content type if content-type is not specified.\n */\nconst getHeaders = response => ({\n  'content-type': response.contentType || 'text/plain',\n  'content-length': response.contentLength || Buffer.byteLength(response.content)\n});\n\n/**\n * sendHead :: object -> object -> Either\n *\n * sendHead triggers responseHook.writeHead side effect and outputs Right(responseHook) on success.\n * sendHead triggers responseHook.writeHead side effect and outputs Left(string) on fail.\n * sendHead uses 200 as response status if no status is specified in the input response object.\n */\nconst sendHead = response => responseHook =>\n  Either.try(() =>\n    passThrough(\n      responseHook => responseHook.writeHead(response.status || 200, getHeaders(response))\n    )(responseHook)\n  );\n\n/**\n * sendContent :: object -> object -> Either\n *\n * sendContent triggers responseHook.end side effect and outputs Right(responseHook) on success.\n * sendContent triggers responseHook.end side effect and outputs Left(string) on fail.\n */\nconst sendContent = response => responseHook =>\n  Either.try(() =>\n    passThrough(\n      responseHook => isJust(response.content) ? responseHook.end(response.content) : responseHook.end()\n    )(responseHook)\n  );\n\n/**\n * streamFile :: object -> object -> Either\n *\n * streamFile triggers read data stream side effect streaming response.file and outputs Right(responseHook) on success.\n * streamFile triggers read data stream side effect streaming response.file and outputs Left(string) on fail.\n */\nconst streamFile = response => responseHook =>\n  fs.existsSync(response.file)\n    ? Either.Right(\n        passThrough(\n          responseHook => fs.createReadStream(response.file).pipe(responseHook)\n          // TODO: catch .on(\"error\", handler) for pipe\n        )(responseHook)\n      )\n    : Either.Left('File does not exist.');\n\n/**\n * sendOrStream :: object -> object -> Either\n *\n * sendOrStream outputs Either calling streamFile or sendContent depending on whether response.file is just.\n */\nconst sendOrStream = response => responseHook =>\n  isJust(response.file)\n    ? streamFile(response)(responseHook)\n    : sendContent(response)(responseHook);\n\n/**\n * ResponseEffect :: object -> object -> SyncEffect(() -> Either(object))\n *\n * ResponseEffect outputs SyncEffect which can trigger side effects responseHook.writeHead and responseHook.end outputting Right(responseHook) on success.\n * ResponseEffect outputs SyncEffect which can trigger side effects responseHook.writeHead and responseHook.end outputting Left(error) on fail.\n */\nconst ResponseEffect = responseHook => response =>\n  SyncEffect\n  .of(() =>\n    Either\n    .of(responseHook)\n    .flatMap(sendHead(response))\n    .flatMap(sendOrStream(response))\n  );\n\nexport default ResponseEffect;\n\nexport {\n  getHeaders,\n  sendHead,\n  sendContent,\n  streamFile,\n  sendOrStream\n}","import {SyncEffect} from \"@7urtle/lambda\";\nimport http from \"http\";\nimport Router from \"./Router\";\nimport RequestEffect from \"./RequestEffect\";\nimport ResponseEffect from \"./ResponseEffect\";\n\n/**\n * resolveResponse :: object -> object -> object\n *\n * resolveResponse creates and triggers ResponseEffect\n */\nconst resolveResponse = configuration => responseHook => request =>\n  ResponseEffect(responseHook)(Router.getResponse(configuration)(request))\n  .trigger();\n\n/**\n * onRequest :: object -> (object, object) -> Either\n *\n * onRequest outputs responseHook executing ResponseEffect side effect based on input configuration, requestHook and responseHook.\n */\nconst onRequest = configuration => (reject, resolve) => (requestHook, responseHook) =>\n  RequestEffect(requestHook)\n  .trigger(\n    error => reject(error),\n    request => resolve(configuration)(responseHook)(request)\n\n  );\n\n/**\n * requestListener :: object -> Server -> Server\n *\n * requestListener reqisters onRequest handler to request listener and outputs Server.'\n */\nconst requestListener = configuration => Server =>\n  Server.on('request', onRequest(configuration)(() => null, resolveResponse));\n// TODO: I am not really processing what happens if onRequest fails... probably log it...\n\n/**\n * listen :: object -> Server -> Server\n *\n * listen calls input Server listen function passing it configuration.port and outputs Server.\n */\nconst listen = configuration => Server => Server.listen(configuration.port);\n\n/**\n * Server :: object -> SyncEffect(http.Server)\n *\n * Server outputs results based on configuration.\n */\nconst Server = configuration =>\n  SyncEffect\n  .of(http.createServer)\n  .map(requestListener(configuration))\n  .map(listen(configuration));\n\nexport default Server;\n\nexport {\n  onRequest,\n  requestListener,\n  listen\n};","import {Either} from '@7urtle/lambda';\n\nconst any = request => Either.Right({\n  status: 404,\n  contentType: 'text/plain',\n  content: 'Not Found'\n});\n\nexport default {any};","import {Either} from '@7urtle/lambda';\n\nconst any = request => Either.Right({\n  status: 500,\n  contentType: 'text/plain',\n  content: 'Internal Server Error'\n});\n\nexport default {any};","import {Either, isEqual} from '@7urtle/lambda';\nimport fs from 'fs';\nimport mimeTypes from 'mime-types';\n\n/**\n * fileExists :: string -> object -> Either\n *\n * fileExists outputs Either of input request if file exists on input path or Either.Left of 404 if it does not.\n */\nconst fileExists = path => request => fs.existsSync(path) ? Either.Right(request) : Either.Left(404);\n\n/**\n * getResponse :: string -> object -> object\n *\n * getResponse outputs response object based on input file path.\n */\nconst getResponse = path => request => ({\n  status: 200,\n  file: isEqual('get')(request.method) ? path : '',\n  contentType: mimeTypes.lookup(path) || 'application/octet-stream',\n  contentLength: fs.statSync(path).size\n});\n\n/**\n * apiFile :: string -> object\n *\n * apiFile outputs api object with get call that outputs response object based on input file path.\n */\nconst apiFile = path => ({\n  get: request =>\n    Either\n    .of(request)\n    .flatMap(fileExists(path))\n    .map(getResponse(path))\n});\n\nexport default apiFile;\n\nexport {\n  fileExists,\n  getResponse\n};","import Server from \"./Server\";\nimport api404 from \"./apis/api404\";\nimport apiError from \"./apis/apiError\";\nimport apiFile from './apis/apiFile';\n\nconst logger = {\n  log: message => console.log(message) || true,\n  info: message => console.log(message) || true,\n  error: message => console.log(message) || true\n};\n\nconst defaultConfiguration = {\n  port: process.env.port || 3000,\n  logger: logger,\n  routes: [],\n  404: api404,\n  error: apiError\n};\n\nconst start = configuration =>\n  Server({\n    ...defaultConfiguration,\n    ...configuration\n  })\n  .trigger();\n\nexport default {start};\n\nexport {\n  apiFile\n};"],"sourceRoot":""}